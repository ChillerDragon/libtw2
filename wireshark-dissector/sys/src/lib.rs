#![allow(bad_style)]
/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const ENC_BIG_ENDIAN: u32 = 0;
pub const ENC_NA: u32 = 0;
pub type __uint64_t = u64;
pub type __time_t = i64;
pub type size_t = usize;
pub type guint8 = u8;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = u16;
pub type gint32 = i32;
pub type guint32 = u32;
pub type guint64 = u64;
pub type gsize = usize;
pub type time_t = __time_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type GHashTable = u8;
pub type GSList = [u64; 2usize];
#[doc = " A public opaque type representing one wmem allocation pool."]
pub type wmem_allocator_t = u8;
extern "C" {
    #[doc = " Allocate the requested amount of memory in the given pool."]
    #[doc = ""]
    #[doc = " @param allocator The allocator object to use to allocate the memory."]
    #[doc = " @param size The amount of memory to allocate."]
    #[doc = " @return A void pointer to the newly allocated memory."]
    pub fn wmem_alloc(
        allocator: *mut wmem_allocator_t,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub type wmem_list_t = u8;
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-map Hash Map"]
#[doc = ""]
#[doc = "    A hash map implementation on top of wmem. Provides insertion, deletion and"]
#[doc = "    lookup in expected amortized constant time. Uses universal hashing to map"]
#[doc = "    keys into buckets, and provides a generic strong hash function that makes"]
#[doc = "    it secure against algorithmic complexity attacks, and suitable for use"]
#[doc = "    even with untrusted data."]
#[doc = ""]
#[doc = "    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_map_t {
    _unused: [u8; 0],
}
pub type wmem_map_t = _wmem_map_t;
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-tree Red/Black Tree"]
#[doc = ""]
#[doc = "    Binary trees are a well-known and popular device in computer science to"]
#[doc = "    handle storage of objects based on a search key or identity. The"]
#[doc = "    particular binary tree style implemented here is the red/black tree, which"]
#[doc = "    has the nice property of being self-balancing. This guarantees O(log(n))"]
#[doc = "    time for lookups, compared to linked lists that are O(n). This means"]
#[doc = "    red/black trees scale very well when many objects are being stored."]
#[doc = ""]
#[doc = "    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_tree_t {
    _unused: [u8; 0],
}
pub type wmem_tree_t = _wmem_tree_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_block {
    _unused: [u8; 0],
}
pub type wtap_block_t = *mut wtap_block;
#[doc = " data structure to hold time values with nanosecond resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nstime_t() {
    assert_eq!(
        ::std::mem::size_of::<nstime_t>(),
        16usize,
        concat!("Size of: ", stringify!(nstime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nstime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nstime_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nstime_t>())).secs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nstime_t>())).nsecs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(nsecs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_guid_t {
    pub data1: guint32,
    pub data2: guint16,
    pub data3: guint16,
    pub data4: [guint8; 8usize],
}
#[test]
fn bindgen_test_layout__e_guid_t() {
    assert_eq!(
        ::std::mem::size_of::<_e_guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_e_guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_e_guid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_e_guid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data4)
        )
    );
}
pub type e_guid_t = _e_guid_t;
pub type tvbuff_t = u8;
extern "C" {
    pub fn tvb_new_child_real_data(
        parent: *mut tvbuff_t,
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Similar to tvb_new_subset_length_caplen() but with backing_length and reported_length set"]
    #[doc = " to -1.  Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_remaining(backing: *mut tvbuff_t, backing_offset: gint) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_reported_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    #[doc = " Returns target for convenience. Does not suffer from possible"]
    #[doc = " expense of tvb_get_ptr(), since this routine is smart enough"]
    #[doc = " to copy data in chunks if the request range actually exists in"]
    #[doc = " different \"real\" tvbuffs. This function assumes that the target"]
    #[doc = " memory is already allocated; it does not allocate or free the"]
    #[doc = " target memory."]
    pub fn tvb_memcpy(
        tvb: *mut tvbuff_t,
        target: *mut ::std::os::raw::c_void,
        offset: gint,
        length: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Buffer {
    pub data: *mut guint8,
    pub allocated: gsize,
    pub start: gsize,
    pub first_free: gsize,
}
#[test]
fn bindgen_test_layout_Buffer() {
    assert_eq!(
        ::std::mem::size_of::<Buffer>(),
        32usize,
        concat!("Size of: ", stringify!(Buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(Buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).allocated as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).first_free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(first_free)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union wtap_pseudo_header {
    pub _bindgen_opaque_blob: [u64; 19usize],
}
#[test]
fn bindgen_test_layout_wtap_pseudo_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_pseudo_header>(),
        152usize,
        concat!("Size of: ", stringify!(wtap_pseudo_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_pseudo_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_pseudo_header))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_packet_header {
    pub caplen: guint32,
    pub len: guint32,
    pub pkt_encap: ::std::os::raw::c_int,
    pub interface_id: guint32,
    pub pseudo_header: wtap_pseudo_header,
}
#[test]
fn bindgen_test_layout_wtap_packet_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_packet_header>(),
        168usize,
        concat!("Size of: ", stringify!(wtap_packet_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_packet_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_packet_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).caplen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(caplen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).pkt_encap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(pkt_encap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).interface_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(interface_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_packet_header>())).pseudo_header as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(pseudo_header)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_ft_specific_header {
    pub record_type: guint,
    pub record_len: guint32,
}
#[test]
fn bindgen_test_layout_wtap_ft_specific_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_ft_specific_header>(),
        8usize,
        concat!("Size of: ", stringify!(wtap_ft_specific_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_ft_specific_header>(),
        4usize,
        concat!("Alignment of ", stringify!(wtap_ft_specific_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_ft_specific_header>())).record_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_ft_specific_header),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_ft_specific_header>())).record_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_ft_specific_header),
            "::",
            stringify!(record_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_syscall_header {
    pub record_type: guint,
    pub byte_order: ::std::os::raw::c_int,
    pub timestamp: guint64,
    pub thread_id: guint64,
    pub event_len: guint32,
    pub event_filelen: guint32,
    pub event_type: guint16,
    pub nparams: guint32,
    pub cpu_id: guint16,
}
#[test]
fn bindgen_test_layout_wtap_syscall_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_syscall_header>(),
        48usize,
        concat!("Size of: ", stringify!(wtap_syscall_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_syscall_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_syscall_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).record_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).byte_order as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).thread_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).event_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_syscall_header>())).event_filelen as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_filelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).event_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).nparams as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(nparams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).cpu_id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(cpu_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_systemd_journal_export_header {
    pub record_len: guint32,
}
#[test]
fn bindgen_test_layout_wtap_systemd_journal_export_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_systemd_journal_export_header>(),
        4usize,
        concat!("Size of: ", stringify!(wtap_systemd_journal_export_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_systemd_journal_export_header>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wtap_systemd_journal_export_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_systemd_journal_export_header>())).record_len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_systemd_journal_export_header),
            "::",
            stringify!(record_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_custom_block_header {
    pub length: guint32,
    pub pen: guint32,
    pub copy_allowed: gboolean,
    pub custom_data_header: wtap_custom_block_header__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_custom_block_header__bindgen_ty_1 {
    pub nflx_custom_data_header: wtap_custom_block_header__bindgen_ty_1_nflx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_custom_block_header__bindgen_ty_1_nflx {
    pub type_: guint32,
    pub skipped: guint32,
}
#[test]
fn bindgen_test_layout_wtap_custom_block_header__bindgen_ty_1_nflx() {
    assert_eq!(
        ::std::mem::size_of::<wtap_custom_block_header__bindgen_ty_1_nflx>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_custom_block_header__bindgen_ty_1_nflx>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_custom_block_header__bindgen_ty_1_nflx>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_custom_block_header__bindgen_ty_1_nflx>())).skipped
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1_nflx),
            "::",
            stringify!(skipped)
        )
    );
}
#[test]
fn bindgen_test_layout_wtap_custom_block_header__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wtap_custom_block_header__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_custom_block_header__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(wtap_custom_block_header__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_custom_block_header__bindgen_ty_1>()))
                .nflx_custom_data_header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header__bindgen_ty_1),
            "::",
            stringify!(nflx_custom_data_header)
        )
    );
}
#[test]
fn bindgen_test_layout_wtap_custom_block_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_custom_block_header>(),
        20usize,
        concat!("Size of: ", stringify!(wtap_custom_block_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_custom_block_header>(),
        4usize,
        concat!("Alignment of ", stringify!(wtap_custom_block_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_custom_block_header>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_custom_block_header>())).pen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(pen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_custom_block_header>())).copy_allowed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(copy_allowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_custom_block_header>())).custom_data_header as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_custom_block_header),
            "::",
            stringify!(custom_data_header)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_rec {
    pub rec_type: guint,
    pub presence_flags: guint32,
    pub section_number: guint,
    pub ts: nstime_t,
    pub tsprec: ::std::os::raw::c_int,
    pub rec_header: wtap_rec__bindgen_ty_1,
    pub block: wtap_block_t,
    pub block_was_modified: gboolean,
    pub options_buf: Buffer,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_rec__bindgen_ty_1 {
    pub packet_header: wtap_packet_header,
    pub ft_specific_header: wtap_ft_specific_header,
    pub syscall_header: wtap_syscall_header,
    pub systemd_journal_export_header: wtap_systemd_journal_export_header,
    pub custom_block_header: wtap_custom_block_header,
}
#[test]
fn bindgen_test_layout_wtap_rec__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wtap_rec__bindgen_ty_1>(),
        168usize,
        concat!("Size of: ", stringify!(wtap_rec__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_rec__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_rec__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).packet_header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(packet_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).ft_specific_header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(ft_specific_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).syscall_header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(syscall_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).systemd_journal_export_header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(systemd_journal_export_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).custom_block_header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(custom_block_header)
        )
    );
}
#[test]
fn bindgen_test_layout_wtap_rec() {
    assert_eq!(
        ::std::mem::size_of::<wtap_rec>(),
        256usize,
        concat!("Size of: ", stringify!(wtap_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).rec_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(rec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).presence_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).section_number as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(section_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).ts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).tsprec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(tsprec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).rec_header as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(rec_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).block as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).block_was_modified as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(block_was_modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).options_buf as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(options_buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
pub type frame_data = [u64; 11usize];
pub type address = [u64; 3usize];
pub const PT_NONE: port_type = 0;
pub const PT_SCTP: port_type = 1;
pub const PT_TCP: port_type = 2;
pub const PT_UDP: port_type = 3;
pub const PT_DCCP: port_type = 4;
pub const PT_IPX: port_type = 5;
pub const PT_DDP: port_type = 6;
pub const PT_IDP: port_type = 7;
pub const PT_USB: port_type = 8;
pub const PT_I2C: port_type = 9;
pub const PT_IBQP: port_type = 10;
pub const PT_BLUETOOTH: port_type = 11;
pub const PT_IWARP_MPA: port_type = 12;
pub type port_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    #[doc = "< name of protocol currently being dissected"]
    pub current_proto: *const ::std::os::raw::c_char,
    #[doc = "< Column formatting information"]
    pub cinfo: *mut epan_column_info,
    #[doc = "< Presence flags for some items"]
    pub presence_flags: guint32,
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet absolute time stamp"]
    pub abs_ts: nstime_t,
    #[doc = "< Relative timestamp (yes, it can be negative)"]
    pub rel_ts: nstime_t,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    #[doc = "< Record metadata"]
    pub rec: *mut wtap_rec,
    #[doc = "< Frame data sources"]
    pub data_src: *mut GSList,
    #[doc = "< link-layer source address"]
    pub dl_src: address,
    #[doc = "< link-layer destination address"]
    pub dl_dst: address,
    #[doc = "< network-layer source address"]
    pub net_src: address,
    #[doc = "< network-layer destination address"]
    pub net_dst: address,
    #[doc = "< source address (net if present, DL otherwise )"]
    pub src: address,
    #[doc = "< destination address (net if present, DL otherwise )"]
    pub dst: address,
    #[doc = "< First encountered VLAN Id if present otherwise 0"]
    pub vlan_id: guint32,
    #[doc = "< reason why reassembly wasn't done, if any"]
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if the protocol is only a fragment"]
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    #[doc = "< type of the following two port numbers"]
    pub ptype: port_type,
    #[doc = "< source port"]
    pub srcport: guint32,
    #[doc = "< destination port"]
    pub destport: guint32,
    #[doc = "< matched uint for calling subdissector from table"]
    pub match_uint: guint32,
    #[doc = "< matched string for calling subdissector from table"]
    pub match_string: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if address/port endpoints member should be used for conversations"]
    pub use_conv_addr_port_endpoints: gboolean,
    #[doc = "< Data that can be used for address+port conversations, including wildcarding"]
    pub conv_addr_port_endpoints: *mut conversation_addr_port_endpoints,
    #[doc = "< Arbritrary conversation identifier; can't be wildcarded"]
    pub conv_elements: *mut conversation_element,
    #[doc = "< >0 if this segment could be desegmented."]
    #[doc = "A dissector that can offer this API (e.g."]
    #[doc = "TCP) sets can_desegment=2, then"]
    #[doc = "can_desegment is decremented by 1 each time"]
    #[doc = "we pass to the next subdissector. Thus only"]
    #[doc = "the dissector immediately above the"]
    #[doc = "protocol which sets the flag can use it"]
    pub can_desegment: guint16,
    #[doc = "< Value of can_desegment before current"]
    #[doc = "dissector was called.  Supplied so that"]
    #[doc = "dissectors for proxy protocols such as"]
    #[doc = "SOCKS can restore it, allowing the"]
    #[doc = "dissectors that they call to use the"]
    #[doc = "TCP dissector's desegmentation (SOCKS"]
    #[doc = "just retransmits TCP segments once it's"]
    #[doc = "finished setting things up, so the TCP"]
    #[doc = "desegmentor can desegment its payload)."]
    pub saved_can_desegment: guint16,
    #[doc = "< offset to stuff needing desegmentation"]
    pub desegment_offset: ::std::os::raw::c_int,
    #[doc = "< requested desegmentation additional length"]
    #[doc = "or"]
    #[doc = "DESEGMENT_ONE_MORE_SEGMENT:"]
    #[doc = "Desegment one more full segment"]
    #[doc = "(warning! only partially implemented)"]
    #[doc = "DESEGMENT_UNTIL_FIN:"]
    #[doc = "Desgment all data for this tcp session"]
    #[doc = "until the FIN segment."]
    pub desegment_len: guint32,
    #[doc = "< >0 if the subdissector has specified"]
    #[doc = "a value in 'bytes_until_next_pdu'."]
    #[doc = "When a dissector detects that the next PDU"]
    #[doc = "will start beyond the start of the next"]
    #[doc = "segment, it can set this value to 2"]
    #[doc = "and 'bytes_until_next_pdu' to the number of"]
    #[doc = "bytes beyond the next segment where the"]
    #[doc = "next PDU starts."]
    #[doc = ""]
    #[doc = "If the protocol dissector below this"]
    #[doc = "one is capable of PDU tracking it can"]
    #[doc = "use this hint to detect PDUs that starts"]
    #[doc = "unaligned to the segment boundaries."]
    #[doc = "The TCP dissector is using this hint from"]
    #[doc = "(some) protocols to detect when a new PDU"]
    #[doc = "starts in the middle of a tcp segment."]
    #[doc = ""]
    #[doc = "There is intelligence in the glue between"]
    #[doc = "dissector layers to make sure that this"]
    #[doc = "request is only passed down to the protocol"]
    #[doc = "immediately below the current one and not"]
    #[doc = "any further."]
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    #[doc = "< Packet was captured as an"]
    #[doc = "outbound (P2P_DIR_SENT)"]
    #[doc = "inbound (P2P_DIR_RECV)"]
    #[doc = "unknown (P2P_DIR_UNKNOWN)"]
    pub p2p_dir: ::std::os::raw::c_int,
    #[doc = "< a hash table passed from one dissector to another"]
    pub private_table: *mut GHashTable,
    #[doc = "< layers of each protocol"]
    pub layers: *mut wmem_list_t,
    pub proto_layers: *mut wmem_map_t,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub curr_layer_num: guint8,
    #[doc = "< The current \"depth\" or layer number for this dissector in the current frame"]
    pub curr_proto_layer_num: guint8,
    pub link_number: guint16,
    #[doc = "< clnp/cotp source reference (can't use srcport, this would confuse tpkt)"]
    pub clnp_srcref: guint16,
    #[doc = "< clnp/cotp destination reference (can't use dstport, this would confuse tpkt)"]
    pub clnp_dstref: guint16,
    #[doc = "< 3GPP messages are sometime different UP link(UL) or Downlink(DL)"]
    pub link_dir: ::std::os::raw::c_int,
    #[doc = "< Rcv.Wind.Shift src applies when sending segments; -1 unknown; -2 disabled"]
    pub src_win_scale: gint16,
    #[doc = "< Rcv.Wind.Shift dst applies when sending segments; -1 unknown; -2 disabled"]
    pub dst_win_scale: gint16,
    #[doc = "< Per packet proto data"]
    pub proto_data: *mut GSList,
    #[doc = "< A list of frames which this one depends on"]
    pub dependent_frames: *mut GSList,
    pub frame_end_routines: *mut GSList,
    #[doc = "< Memory pool scoped to the pinfo struct"]
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    #[doc = "< name of heur list if this packet is being heuristically dissected"]
    pub heur_list_name: *const gchar,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__packet_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_packet_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_packet_info__bindgen_ty_1))
    );
}
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__packet_info() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info>(),
        416usize,
        concat!("Size of: ", stringify!(_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_packet_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).current_proto as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(current_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).cinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(cinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).presence_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).num as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).abs_ts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(abs_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).rel_ts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).fd as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).pseudo_header as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pseudo_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).rec as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).data_src as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(data_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dl_src as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dl_dst as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).net_src as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).net_dst as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).src as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dst as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).vlan_id as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).noreassembly_reason as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(noreassembly_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).fragmented as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fragmented)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).flags as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).ptype as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(ptype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).srcport as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(srcport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).destport as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(destport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).match_uint as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).match_string as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).use_conv_addr_port_endpoints as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(use_conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).conv_addr_port_endpoints as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).conv_elements as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).can_desegment as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(can_desegment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).saved_can_desegment as *const _ as usize
        },
        306usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(saved_can_desegment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).desegment_offset as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).desegment_len as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).want_pdu_tracking as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(want_pdu_tracking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).bytes_until_next_pdu as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(bytes_until_next_pdu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).p2p_dir as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(p2p_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).private_table as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(private_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).layers as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).proto_layers as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).curr_layer_num as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_layer_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).curr_proto_layer_num as *const _ as usize
        },
        353usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_proto_layer_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).link_number as *const _ as usize },
        354usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).clnp_srcref as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_srcref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).clnp_dstref as *const _ as usize },
        358usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_dstref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).link_dir as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).src_win_scale as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src_win_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dst_win_scale as *const _ as usize },
        366usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst_win_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).proto_data as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dependent_frames as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dependent_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).frame_end_routines as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(frame_end_routines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).pool as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).epan as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(epan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).heur_list_name as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(heur_list_name)
        )
    );
}
pub type packet_info = _packet_info;
pub const FT_NONE: ftenum = 0;
pub const FT_PROTOCOL: ftenum = 1;
pub const FT_BOOLEAN: ftenum = 2;
pub const FT_CHAR: ftenum = 3;
pub const FT_UINT8: ftenum = 4;
pub const FT_UINT16: ftenum = 5;
pub const FT_UINT24: ftenum = 6;
pub const FT_UINT32: ftenum = 7;
pub const FT_UINT40: ftenum = 8;
pub const FT_UINT48: ftenum = 9;
pub const FT_UINT56: ftenum = 10;
pub const FT_UINT64: ftenum = 11;
pub const FT_INT8: ftenum = 12;
pub const FT_INT16: ftenum = 13;
pub const FT_INT24: ftenum = 14;
pub const FT_INT32: ftenum = 15;
pub const FT_INT40: ftenum = 16;
pub const FT_INT48: ftenum = 17;
pub const FT_INT56: ftenum = 18;
pub const FT_INT64: ftenum = 19;
pub const FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const FT_IEEE_11073_FLOAT: ftenum = 21;
pub const FT_FLOAT: ftenum = 22;
pub const FT_DOUBLE: ftenum = 23;
pub const FT_ABSOLUTE_TIME: ftenum = 24;
pub const FT_RELATIVE_TIME: ftenum = 25;
pub const FT_STRING: ftenum = 26;
pub const FT_STRINGZ: ftenum = 27;
pub const FT_UINT_STRING: ftenum = 28;
pub const FT_ETHER: ftenum = 29;
pub const FT_BYTES: ftenum = 30;
pub const FT_UINT_BYTES: ftenum = 31;
pub const FT_IPv4: ftenum = 32;
pub const FT_IPv6: ftenum = 33;
pub const FT_IPXNET: ftenum = 34;
pub const FT_FRAMENUM: ftenum = 35;
pub const FT_GUID: ftenum = 36;
pub const FT_OID: ftenum = 37;
pub const FT_EUI64: ftenum = 38;
pub const FT_AX25: ftenum = 39;
pub const FT_VINES: ftenum = 40;
pub const FT_REL_OID: ftenum = 41;
pub const FT_SYSTEM_ID: ftenum = 42;
pub const FT_STRINGZPAD: ftenum = 43;
pub const FT_FCWWN: ftenum = 44;
pub const FT_STRINGZTRUNC: ftenum = 45;
pub const FT_NUM_TYPES: ftenum = 46;
pub type ftenum = ::std::os::raw::c_uint;
#[doc = "< none"]
pub const BASE_NONE: field_display_e = 0;
#[doc = "< decimal [integer, float]"]
pub const BASE_DEC: field_display_e = 1;
#[doc = "< hexadecimal [integer, float]"]
pub const BASE_HEX: field_display_e = 2;
#[doc = "< octal [integer]"]
pub const BASE_OCT: field_display_e = 3;
#[doc = "< decimal (hexadecimal) [integer]"]
pub const BASE_DEC_HEX: field_display_e = 4;
#[doc = "< hexadecimal (decimal) [integer]"]
pub const BASE_HEX_DEC: field_display_e = 5;
#[doc = "< call custom routine to format [integer, float]"]
pub const BASE_CUSTOM: field_display_e = 6;
#[doc = "< exponential [float]"]
pub const BASE_EXP: field_display_e = 7;
#[doc = "< hexadecimal bytes with a period (.) between each byte"]
pub const SEP_DOT: field_display_e = 8;
#[doc = "< hexadecimal bytes with a dash (-) between each byte"]
pub const SEP_DASH: field_display_e = 9;
#[doc = "< hexadecimal bytes with a colon (:) between each byte"]
pub const SEP_COLON: field_display_e = 10;
#[doc = "< hexadecimal bytes with a space between each byte"]
pub const SEP_SPACE: field_display_e = 11;
#[doc = "< Used for IPv4 address that shouldn't be resolved (like for netmasks)"]
pub const BASE_NETMASK: field_display_e = 12;
#[doc = "< UDP port"]
pub const BASE_PT_UDP: field_display_e = 13;
#[doc = "< TCP port"]
pub const BASE_PT_TCP: field_display_e = 14;
#[doc = "< DCCP port"]
pub const BASE_PT_DCCP: field_display_e = 15;
#[doc = "< SCTP port"]
pub const BASE_PT_SCTP: field_display_e = 16;
#[doc = "< OUI resolution"]
pub const BASE_OUI: field_display_e = 17;
#[doc = "< local time in our time zone, with month and day"]
pub const ABSOLUTE_TIME_LOCAL: field_display_e = 18;
#[doc = "< UTC, with month and day"]
pub const ABSOLUTE_TIME_UTC: field_display_e = 19;
#[doc = "< UTC, with 1-origin day-of-year"]
pub const ABSOLUTE_TIME_DOY_UTC: field_display_e = 20;
#[doc = "< UTC, with \"NULL\" when timestamp is all zeros"]
pub const ABSOLUTE_TIME_NTP_UTC: field_display_e = 21;
pub type field_display_e = ::std::os::raw::c_uint;
#[doc = "< Field is not referenced"]
pub const HF_REF_TYPE_NONE: hf_ref_type = 0;
#[doc = "< Field is indirectly referenced (only applicable for FT_PROTOCOL) via. its child"]
pub const HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
#[doc = "< Field is directly referenced"]
pub const HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = ::std::os::raw::c_uint;
#[doc = " information describing a header field"]
pub type header_field_info = _header_field_info;
#[doc = " information describing a header field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    #[doc = "< [FIELDNAME] full name of this field"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDFILTERNAME] filter name of this field"]
    pub abbrev: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDTYPE] field type, one of FT_ (from ftypes.h)"]
    pub type_: ftenum,
    #[doc = "< [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask"]
    pub display: ::std::os::raw::c_int,
    #[doc = "< [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,"]
    #[doc = "typically converted by VALS(), RVALS() or TFS()."]
    #[doc = "If this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the"]
    #[doc = "associated protocol_t structure"]
    pub strings: *const ::std::os::raw::c_void,
    #[doc = "< [BITMASK] bitmask of interesting bits"]
    pub bitmask: guint64,
    #[doc = "< [FIELDDESCR] Brief description of field"]
    pub blurb: *const ::std::os::raw::c_char,
    #[doc = "< Field ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< parent protocol tree"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "< is this field referenced by a filter"]
    pub ref_type: hf_ref_type,
    #[doc = "< ID of previous hfinfo with same abbrev"]
    pub same_name_prev_id: ::std::os::raw::c_int,
    #[doc = "< Link to next hfinfo with same abbrev"]
    pub same_name_next: *mut header_field_info,
}
#[test]
fn bindgen_test_layout__header_field_info() {
    assert_eq!(
        ::std::mem::size_of::<_header_field_info>(),
        72usize,
        concat!("Size of: ", stringify!(_header_field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_header_field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_header_field_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).abbrev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(abbrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).display as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).strings as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).bitmask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(bitmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).blurb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(blurb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).parent as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).ref_type as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(ref_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_header_field_info>())).same_name_prev_id as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_prev_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_header_field_info>())).same_name_next as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_next)
        )
    );
}
#[doc = " Used when registering many fields at once, using proto_register_field_array()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hf_register_info {
    #[doc = "< written to by register() function"]
    pub p_id: *mut ::std::os::raw::c_int,
    #[doc = "< the field info to be registered"]
    pub hfinfo: header_field_info,
}
#[test]
fn bindgen_test_layout_hf_register_info() {
    assert_eq!(
        ::std::mem::size_of::<hf_register_info>(),
        80usize,
        concat!("Size of: ", stringify!(hf_register_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hf_register_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hf_register_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hf_register_info>())).p_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(p_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hf_register_info>())).hfinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(hfinfo)
        )
    );
}
#[doc = " Each proto_tree, proto_item is one of these."]
pub type proto_tree = [u64; 6usize];
#[doc = " Each proto_tree, proto_item is one of these."]
pub type proto_item = [u64; 6usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_plugin {
    pub register_protoinfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_handoff: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_proto_plugin() {
    assert_eq!(
        ::std::mem::size_of::<proto_plugin>(),
        16usize,
        concat!("Size of: ", stringify!(proto_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<proto_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(proto_plugin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proto_plugin>())).register_protoinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_protoinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proto_plugin>())).register_handoff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_handoff)
        )
    );
}
extern "C" {
    #[doc = " Register dissector plugin with the plugin system."]
    pub fn proto_register_plugin(plugin: *const proto_plugin);
}
extern "C" {
    #[doc = " Create a subtree under an existing item."]
    #[doc = "@param pi the parent item of the new subtree"]
    #[doc = "@param idx one of the ett_ array elements registered with proto_register_subtree_array()"]
    #[doc = "@return the new subtree"]
    pub fn proto_item_add_subtree(pi: *mut proto_item, idx: gint) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Replace text of item after it already has been created."]
    #[doc = "@param pi the item to set the text"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    pub fn proto_item_set_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Append to text of item after it has already been created."]
    #[doc = "@param pi the item to append the text to"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    pub fn proto_item_append_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn proto_tree_add_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_NONE field to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_none_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree like proto_tree_add_bytes,"]
    #[doc = "but used when the tvb data length does not match the bytes length."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param ptr_length length of data in start_ptr"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_with_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        ptr_length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_GUID to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC to a"]
    #[doc = "proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC"]
    #[doc = "to a proto_tree, with the format generating the entire string for the"]
    #[doc = "entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BOOLEAN to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_FLOAT to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,"]
    #[doc = "with the format generating the entire string for the entry, including any"]
    #[doc = "field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,"]
    #[doc = "with the format generating the entire string for the entry, including"]
    #[doc = "any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Register a new protocol."]
    #[doc = "@param name the full name of the new protocol"]
    #[doc = "@param short_name abbreviated name of the new protocol"]
    #[doc = "@param filter_name protocol name used for a display filter string"]
    #[doc = "@return the new protocol handle"]
    pub fn proto_register_protocol(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a header_field array."]
    #[doc = "@param parent the protocol handle from proto_register_protocol()"]
    #[doc = "@param hf the hf_register_info array"]
    #[doc = "@param num_records the number of records in hf"]
    pub fn proto_register_field_array(
        parent: ::std::os::raw::c_int,
        hf: *mut hf_register_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Register a protocol subtree (ett) array."]
    #[doc = "@param indices array of ett indices"]
    #[doc = "@param num_indices the number of records in indices"]
    pub fn proto_register_subtree_array(
        indices: *const *mut gint,
        num_indices: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range_admin_tag {
    pub low: guint32,
    pub high: guint32,
}
#[test]
fn bindgen_test_layout_range_admin_tag() {
    assert_eq!(
        ::std::mem::size_of::<range_admin_tag>(),
        8usize,
        concat!("Size of: ", stringify!(range_admin_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<range_admin_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(range_admin_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_admin_tag>())).low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range_admin_tag),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range_admin_tag>())).high as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(range_admin_tag),
            "::",
            stringify!(high)
        )
    );
}
pub type range_admin_t = range_admin_tag;
#[doc = " user specified range(s)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_range {
    #[doc = "< number of entries in ranges"]
    pub nranges: guint,
    #[doc = "< variable-length array"]
    pub ranges: [range_admin_t; 1usize],
}
#[test]
fn bindgen_test_layout_epan_range() {
    assert_eq!(
        ::std::mem::size_of::<epan_range>(),
        12usize,
        concat!("Size of: ", stringify!(epan_range))
    );
    assert_eq!(
        ::std::mem::align_of::<epan_range>(),
        4usize,
        concat!("Alignment of ", stringify!(epan_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epan_range>())).nranges as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_range),
            "::",
            stringify!(nranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<epan_range>())).ranges as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_range),
            "::",
            stringify!(ranges)
        )
    );
}
#[doc = "  Helper routines for column utility structures and routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
pub type column_info = epan_column_info;
#[doc = "< 0) 802.1Q vlan ID"]
pub const COL_8021Q_VLAN_ID: ::std::os::raw::c_uint = 0;
#[doc = "< 1) Absolute date, as YYYY-MM-DD, and time"]
pub const COL_ABS_YMD_TIME: ::std::os::raw::c_uint = 1;
#[doc = "< 2) Absolute date, as YYYY/DOY, and time"]
pub const COL_ABS_YDOY_TIME: ::std::os::raw::c_uint = 2;
#[doc = "< 3) Absolute time"]
pub const COL_ABS_TIME: ::std::os::raw::c_uint = 3;
#[doc = "< 4) VSAN - Cisco MDS-specific"]
pub const COL_VSAN: ::std::os::raw::c_uint = 4;
#[doc = "< 5) Cumulative number of bytes"]
pub const COL_CUMULATIVE_BYTES: ::std::os::raw::c_uint = 5;
#[doc = "< 6) Custom column (any filter name's contents)"]
pub const COL_CUSTOM: ::std::os::raw::c_uint = 6;
#[doc = "< 7) DCE/RPC connection oriented call id OR datagram sequence number"]
pub const COL_DCE_CALL: ::std::os::raw::c_uint = 7;
#[doc = "< 8) Delta time"]
pub const COL_DELTA_TIME: ::std::os::raw::c_uint = 8;
#[doc = "< 9) Delta time displayed"]
pub const COL_DELTA_TIME_DIS: ::std::os::raw::c_uint = 9;
#[doc = "< 10) Resolved dest"]
pub const COL_RES_DST: ::std::os::raw::c_uint = 10;
#[doc = "< 11) Unresolved dest"]
pub const COL_UNRES_DST: ::std::os::raw::c_uint = 11;
#[doc = "< 12) Resolved dest port"]
pub const COL_RES_DST_PORT: ::std::os::raw::c_uint = 12;
#[doc = "< 13) Unresolved dest port"]
pub const COL_UNRES_DST_PORT: ::std::os::raw::c_uint = 13;
#[doc = "< 14) Destination address"]
pub const COL_DEF_DST: ::std::os::raw::c_uint = 14;
#[doc = "< 15) Destination port"]
pub const COL_DEF_DST_PORT: ::std::os::raw::c_uint = 15;
#[doc = "< 16) Expert Info"]
pub const COL_EXPERT: ::std::os::raw::c_uint = 16;
#[doc = "< 17) FW-1 monitor interface/direction"]
pub const COL_IF_DIR: ::std::os::raw::c_uint = 17;
#[doc = "< 18) IEEE 802.11 (and WiMax?) - Channel"]
pub const COL_FREQ_CHAN: ::std::os::raw::c_uint = 18;
#[doc = "< 19) Data link layer dest address"]
pub const COL_DEF_DL_DST: ::std::os::raw::c_uint = 19;
#[doc = "< 20) Data link layer source address"]
pub const COL_DEF_DL_SRC: ::std::os::raw::c_uint = 20;
#[doc = "< 21) Resolved DL dest"]
pub const COL_RES_DL_DST: ::std::os::raw::c_uint = 21;
#[doc = "< 22) Unresolved DL dest"]
pub const COL_UNRES_DL_DST: ::std::os::raw::c_uint = 22;
#[doc = "< 23) Resolved DL source"]
pub const COL_RES_DL_SRC: ::std::os::raw::c_uint = 23;
#[doc = "< 24) Unresolved DL source"]
pub const COL_UNRES_DL_SRC: ::std::os::raw::c_uint = 24;
#[doc = "< 25) IEEE 802.11 - received signal strength"]
pub const COL_RSSI: ::std::os::raw::c_uint = 25;
#[doc = "< 26) IEEE 802.11 - TX rate in Mbps"]
pub const COL_TX_RATE: ::std::os::raw::c_uint = 26;
#[doc = "< 27) IP DSCP Value"]
pub const COL_DSCP_VALUE: ::std::os::raw::c_uint = 27;
#[doc = "< 28) Description"]
pub const COL_INFO: ::std::os::raw::c_uint = 28;
#[doc = "< 29) Resolved net dest"]
pub const COL_RES_NET_DST: ::std::os::raw::c_uint = 29;
#[doc = "< 30) Unresolved net dest"]
pub const COL_UNRES_NET_DST: ::std::os::raw::c_uint = 30;
#[doc = "< 31) Resolved net source"]
pub const COL_RES_NET_SRC: ::std::os::raw::c_uint = 31;
#[doc = "< 32) Unresolved net source"]
pub const COL_UNRES_NET_SRC: ::std::os::raw::c_uint = 32;
#[doc = "< 33) Network layer dest address"]
pub const COL_DEF_NET_DST: ::std::os::raw::c_uint = 33;
#[doc = "< 34) Network layer source address"]
pub const COL_DEF_NET_SRC: ::std::os::raw::c_uint = 34;
#[doc = "< 35) Packet list item number"]
pub const COL_NUMBER: ::std::os::raw::c_uint = 35;
#[doc = "< 36) Packet length in bytes"]
pub const COL_PACKET_LENGTH: ::std::os::raw::c_uint = 36;
#[doc = "< 37) Protocol"]
pub const COL_PROTOCOL: ::std::os::raw::c_uint = 37;
#[doc = "< 38) Relative time"]
pub const COL_REL_TIME: ::std::os::raw::c_uint = 38;
#[doc = "< 39) Source address"]
pub const COL_DEF_SRC: ::std::os::raw::c_uint = 39;
#[doc = "< 40) Source port"]
pub const COL_DEF_SRC_PORT: ::std::os::raw::c_uint = 40;
#[doc = "< 41) Resolved source"]
pub const COL_RES_SRC: ::std::os::raw::c_uint = 41;
#[doc = "< 42) Unresolved source"]
pub const COL_UNRES_SRC: ::std::os::raw::c_uint = 42;
#[doc = "< 43) Resolved source port"]
pub const COL_RES_SRC_PORT: ::std::os::raw::c_uint = 43;
#[doc = "< 44) Unresolved source port"]
pub const COL_UNRES_SRC_PORT: ::std::os::raw::c_uint = 44;
#[doc = "< 45) Q.921 TEI"]
pub const COL_TEI: ::std::os::raw::c_uint = 45;
#[doc = "< 46) UTC date, as YYYY-MM-DD, and time"]
pub const COL_UTC_YMD_TIME: ::std::os::raw::c_uint = 46;
#[doc = "< 47) UTC date, as YYYY/DOY, and time"]
pub const COL_UTC_YDOY_TIME: ::std::os::raw::c_uint = 47;
#[doc = "< 48) UTC time"]
pub const COL_UTC_TIME: ::std::os::raw::c_uint = 48;
#[doc = "< 49) Command line-specified time (default relative)"]
pub const COL_CLS_TIME: ::std::os::raw::c_uint = 49;
#[doc = "< 50) Should always be last"]
pub const NUM_COL_FMTS: ::std::os::raw::c_uint = 50;
#[doc = " All of the possible columns in summary listing."]
#[doc = ""]
#[doc = " NOTE1: The entries MUST remain in this order, or else you need to reorder"]
#[doc = "        the slist[] and dlist[] arrays in column.c to match!"]
#[doc = ""]
#[doc = " NOTE2: Please add the COL_XYZ entry in the appropriate spot, such that the"]
#[doc = "        dlist[] array remains in alphabetical order!"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Clears the text of a column element."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Set (replace) the text of a column element, the text won't be copied."]
    #[doc = ""]
    #[doc = " Usually used to set const strings!"]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param str the string to set"]
    pub fn col_set_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
extern "C" {
    #[doc = " Add (replace) the text of a column element, the text will be copied."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param str the string to add"]
    pub fn col_add_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
pub type dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Type of a heuristic dissector, used in heur_dissector_add()."]
#[doc = ""]
#[doc = " @param tvb the tvbuff with the (remaining) packet data"]
#[doc = " @param pinfo the packet info of this packet (additional info)"]
#[doc = " @param tree the protocol tree to be build or NULL"]
#[doc = " @return TRUE if the packet was recognized by the sub-dissector (stop dissection here)"]
pub type heur_dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        arg1: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
pub const HEURISTIC_DISABLE: heuristic_enable_e = 0;
pub const HEURISTIC_ENABLE: heuristic_enable_e = 1;
pub type heuristic_enable_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn dissector_add_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_with_preference(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_range(
        abbrev: *const ::std::os::raw::c_char,
        range: *mut epan_range,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_range_with_preference(
        abbrev: *const ::std::os::raw::c_char,
        range_str: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_custom_table_handle(
        name: *const ::std::os::raw::c_char,
        pattern: *mut ::std::os::raw::c_void,
        handle: dissector_handle_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _guid_key {
    pub guid: e_guid_t,
    pub ver: guint16,
}
#[test]
fn bindgen_test_layout__guid_key() {
    assert_eq!(
        ::std::mem::size_of::<_guid_key>(),
        20usize,
        concat!("Size of: ", stringify!(_guid_key))
    );
    assert_eq!(
        ::std::mem::align_of::<_guid_key>(),
        4usize,
        concat!("Alignment of ", stringify!(_guid_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_guid_key>())).guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_guid_key),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_guid_key>())).ver as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_guid_key),
            "::",
            stringify!(ver)
        )
    );
}
pub type guid_key = _guid_key;
extern "C" {
    pub fn dissector_add_guid(
        name: *const ::std::os::raw::c_char,
        guid_val: *mut guid_key,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_for_decode_as(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_for_decode_as_with_preference(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    #[doc = " Add a sub-dissector to a heuristic dissector list."]
    #[doc = "  Call this in the proto_handoff function of the sub-dissector."]
    #[doc = ""]
    #[doc = " @param name the name of the heuristic dissector table into which to register the dissector, e.g. \"tcp\""]
    #[doc = " @param dissector the sub-dissector to be registered"]
    #[doc = " @param display_name the string used to present heuristic to user, e.g. \"HTTP over TCP\""]
    #[doc = " @param internal_name the string used for \"internal\" use to identify heuristic, e.g. \"http_tcp\""]
    #[doc = " @param proto the protocol id of the sub-dissector"]
    #[doc = " @param enable initially enabled or not"]
    pub fn heur_dissector_add(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        display_name: *const ::std::os::raw::c_char,
        internal_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        enable: heuristic_enable_e,
    );
}
extern "C" {
    #[doc = " Create an anonymous handle for a dissector."]
    pub fn create_dissector_handle(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn add_new_data_source(
        pinfo: *mut packet_info,
        tvb: *mut tvbuff_t,
        name: *const ::std::os::raw::c_char,
    );
}
pub const CONVERSATION_NONE: conversation_type = 0;
pub const CONVERSATION_SCTP: conversation_type = 1;
pub const CONVERSATION_TCP: conversation_type = 2;
pub const CONVERSATION_UDP: conversation_type = 3;
pub const CONVERSATION_DCCP: conversation_type = 4;
pub const CONVERSATION_IPX: conversation_type = 5;
pub const CONVERSATION_NCP: conversation_type = 6;
pub const CONVERSATION_EXCHG: conversation_type = 7;
pub const CONVERSATION_DDP: conversation_type = 8;
pub const CONVERSATION_SBCCS: conversation_type = 9;
pub const CONVERSATION_IDP: conversation_type = 10;
pub const CONVERSATION_TIPC: conversation_type = 11;
pub const CONVERSATION_USB: conversation_type = 12;
pub const CONVERSATION_I2C: conversation_type = 13;
pub const CONVERSATION_IBQP: conversation_type = 14;
pub const CONVERSATION_BLUETOOTH: conversation_type = 15;
pub const CONVERSATION_TDMOP: conversation_type = 16;
pub const CONVERSATION_DVBCI: conversation_type = 17;
pub const CONVERSATION_ISO14443: conversation_type = 18;
pub const CONVERSATION_ISDN: conversation_type = 19;
pub const CONVERSATION_H223: conversation_type = 20;
pub const CONVERSATION_X25: conversation_type = 21;
pub const CONVERSATION_IAX2: conversation_type = 22;
pub const CONVERSATION_DLCI: conversation_type = 23;
pub const CONVERSATION_ISUP: conversation_type = 24;
pub const CONVERSATION_BICC: conversation_type = 25;
pub const CONVERSATION_GSMTAP: conversation_type = 26;
pub const CONVERSATION_IUUP: conversation_type = 27;
pub const CONVERSATION_DVBBBF: conversation_type = 28;
pub const CONVERSATION_IWARP_MPA: conversation_type = 29;
pub const CONVERSATION_BT_UTP: conversation_type = 30;
pub const CONVERSATION_LOG: conversation_type = 31;
pub type conversation_type = ::std::os::raw::c_uint;
pub const CE_CONVERSATION_TYPE: conversation_element_type = 0;
pub const CE_ADDRESS: conversation_element_type = 1;
pub const CE_PORT: conversation_element_type = 2;
pub const CE_STRING: conversation_element_type = 3;
pub const CE_UINT: conversation_element_type = 4;
pub const CE_UINT64: conversation_element_type = 5;
#[doc = " Conversation element type."]
pub type conversation_element_type = ::std::os::raw::c_uint;
#[doc = " Elements used to identify conversations for *_full routines and"]
#[doc = " pinfo->conv_elements."]
#[doc = " Arrays must be terminated with an element .type set to CE_CONVERSATION_TYPE."]
#[doc = ""]
#[doc = " This is currently set only by conversation_set_elements_by_id(); it"]
#[doc = " is not set for conversations identified by address/port endpoints."]
#[doc = ""]
#[doc = " In find_conversation_pinfo() and find_or_create_conversation(), if"]
#[doc = " any dissector has set this, then, unless some dissector has set the"]
#[doc = " pair of address/port endpoints (see below), the array of elements"]
#[doc = " is used to look up or create the conversation.  Otherwise, the"]
#[doc = " current addresses and ports in the packet_info structure are used."]
#[doc = ""]
#[doc = " XXX - is there any reason why we shouldn't use an array of conversation"]
#[doc = " elements, with the appropriate addresses and ports, and set it for"]
#[doc = " all protocols that use conversations specified by a pair of address/port"]
#[doc = " endpoints?  That might simplify find_conversation_pinfo() by having"]
#[doc = " them always use the array of elements if it's present, and just fail if"]
#[doc = " it's not."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct conversation_element {
    pub type_: conversation_element_type,
    pub __bindgen_anon_1: conversation_element__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union conversation_element__bindgen_ty_1 {
    pub conversation_type_val: conversation_type,
    pub addr_val: address,
    pub port_val: ::std::os::raw::c_uint,
    pub str_val: *const ::std::os::raw::c_char,
    pub uint_val: ::std::os::raw::c_uint,
    pub uint64_val: u64,
}
#[test]
fn bindgen_test_layout_conversation_element__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<conversation_element__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(conversation_element__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation_element__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(conversation_element__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<conversation_element__bindgen_ty_1>())).conversation_type_val
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(conversation_type_val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<conversation_element__bindgen_ty_1>())).addr_val as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(addr_val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<conversation_element__bindgen_ty_1>())).port_val as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(port_val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<conversation_element__bindgen_ty_1>())).str_val as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(str_val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<conversation_element__bindgen_ty_1>())).uint_val as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(uint_val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<conversation_element__bindgen_ty_1>())).uint64_val as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(uint64_val)
        )
    );
}
#[test]
fn bindgen_test_layout_conversation_element() {
    assert_eq!(
        ::std::mem::size_of::<conversation_element>(),
        32usize,
        concat!("Size of: ", stringify!(conversation_element))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation_element>(),
        8usize,
        concat!("Alignment of ", stringify!(conversation_element))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation_element>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " Elements used to identify conversations for *_full routines and"]
#[doc = " pinfo->conv_elements."]
#[doc = " Arrays must be terminated with an element .type set to CE_CONVERSATION_TYPE."]
#[doc = ""]
#[doc = " This is currently set only by conversation_set_elements_by_id(); it"]
#[doc = " is not set for conversations identified by address/port endpoints."]
#[doc = ""]
#[doc = " In find_conversation_pinfo() and find_or_create_conversation(), if"]
#[doc = " any dissector has set this, then, unless some dissector has set the"]
#[doc = " pair of address/port endpoints (see below), the array of elements"]
#[doc = " is used to look up or create the conversation.  Otherwise, the"]
#[doc = " current addresses and ports in the packet_info structure are used."]
#[doc = ""]
#[doc = " XXX - is there any reason why we shouldn't use an array of conversation"]
#[doc = " elements, with the appropriate addresses and ports, and set it for"]
#[doc = " all protocols that use conversations specified by a pair of address/port"]
#[doc = " endpoints?  That might simplify find_conversation_pinfo() by having"]
#[doc = " them always use the array of elements if it's present, and just fail if"]
#[doc = " it's not."]
pub type conversation_element_t = conversation_element;
#[doc = " Data structure representing a conversation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation {
    pub next: *mut conversation,
    #[doc = " pointer to next conversation on hash chain"]
    pub last: *mut conversation,
    #[doc = " pointer to the last conversation on hash chain"]
    pub latest_found: *mut conversation,
    #[doc = " pointer to the last conversation on hash chain"]
    pub conv_index: guint32,
    #[doc = " unique ID for conversation"]
    pub setup_frame: guint32,
    #[doc = " frame number that setup this conversation"]
    pub last_frame: guint32,
    #[doc = " highest frame number in this conversation"]
    pub data_list: *mut wmem_tree_t,
    #[doc = " list of data associated with conversation"]
    pub dissector_tree: *mut wmem_tree_t,
    #[doc = " tree containing protocol dissector client associated with conversation"]
    pub options: guint,
    #[doc = " wildcard flags"]
    pub key_ptr: *mut conversation_element_t,
}
#[test]
fn bindgen_test_layout_conversation() {
    assert_eq!(
        ::std::mem::size_of::<conversation>(),
        72usize,
        concat!("Size of: ", stringify!(conversation))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation>(),
        8usize,
        concat!("Alignment of ", stringify!(conversation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).latest_found as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(latest_found)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).conv_index as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(conv_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).setup_frame as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(setup_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).last_frame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(last_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).data_list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(data_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).dissector_tree as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(dissector_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).options as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<conversation>())).key_ptr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(key_ptr)
        )
    );
}
#[doc = " Data structure representing a conversation."]
pub type conversation_t = conversation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation_addr_port_endpoints {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " A helper function that calls find_conversation() and, if a conversation is"]
    #[doc = " not found, calls conversation_new()."]
    #[doc = " The frame number and addresses are taken from pinfo."]
    #[doc = " No options are used, though we could extend this API to include an options"]
    #[doc = " parameter."]
    #[doc = ""]
    #[doc = " @param pinfo Packet info."]
    #[doc = " @return The existing or new conversation."]
    pub fn find_or_create_conversation(pinfo: *mut packet_info) -> *mut conversation_t;
}
extern "C" {
    pub fn conversation_set_dissector(
        conversation: *mut conversation_t,
        handle: dissector_handle_t,
    );
}

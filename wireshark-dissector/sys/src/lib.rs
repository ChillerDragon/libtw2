#![allow(bad_style)]
/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const ENC_BIG_ENDIAN: u32 = 0;
pub const ENC_NA: u32 = 0;
pub type size_t = ::std::os::raw::c_ulong;
pub type guint8 = ::std::os::raw::c_uchar;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type time_t = __time_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type GByteArray = [u64; 2usize];
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).pdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
pub type GHashTable = u8;
pub type GSList = [u64; 2usize];
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " A public opaque type representing one wmem allocation pool."]
pub type wmem_allocator_t = u8;
extern "C" {
    #[doc = " Allocate the requested amount of memory in the given pool."]
    #[doc = ""]
    #[doc = " @param allocator The allocator object to use to allocate the memory."]
    #[doc = " @param size The amount of memory to allocate."]
    #[doc = " @return A void pointer to the newly allocated memory."]
    pub fn wmem_alloc(
        allocator: *mut wmem_allocator_t,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub type wmem_list_t = u8;
#[doc = " data structure to hold time values with nanosecond resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nstime_t() {
    assert_eq!(
        ::std::mem::size_of::<nstime_t>(),
        16usize,
        concat!("Size of: ", stringify!(nstime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nstime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nstime_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nstime_t>())).secs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nstime_t>())).nsecs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(nsecs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_guid_t {
    pub data1: guint32,
    pub data2: guint16,
    pub data3: guint16,
    pub data4: [guint8; 8usize],
}
#[test]
fn bindgen_test_layout__e_guid_t() {
    assert_eq!(
        ::std::mem::size_of::<_e_guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_e_guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_e_guid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_e_guid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_e_guid_t>())).data4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data4)
        )
    );
}
pub type e_guid_t = _e_guid_t;
pub type tvbuff_t = u8;
extern "C" {
    pub fn tvb_new_child_real_data(
        parent: *mut tvbuff_t,
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Similar to tvb_new_subset_length_caplen() but with backing_length and reported_length set"]
    #[doc = " to -1.  Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_remaining(backing: *mut tvbuff_t, backing_offset: gint) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_reported_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    #[doc = " Returns target for convenience. Does not suffer from possible"]
    #[doc = " expense of tvb_get_ptr(), since this routine is smart enough"]
    #[doc = " to copy data in chunks if the request range actually exists in"]
    #[doc = " different \"real\" tvbuffs. This function assumes that the target"]
    #[doc = " memory is already allocated; it does not allocate or free the"]
    #[doc = " target memory."]
    pub fn tvb_memcpy(
        tvb: *mut tvbuff_t,
        target: *mut ::std::os::raw::c_void,
        offset: gint,
        length: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Buffer {
    pub data: *mut guint8,
    pub allocated: gsize,
    pub start: gsize,
    pub first_free: gsize,
}
#[test]
fn bindgen_test_layout_Buffer() {
    assert_eq!(
        ::std::mem::size_of::<Buffer>(),
        32usize,
        concat!("Size of: ", stringify!(Buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(Buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).allocated as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Buffer>())).first_free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Buffer),
            "::",
            stringify!(first_free)
        )
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union wtap_pseudo_header {
    pub _bindgen_opaque_blob: [u64; 19usize],
}
#[test]
fn bindgen_test_layout_wtap_pseudo_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_pseudo_header>(),
        152usize,
        concat!("Size of: ", stringify!(wtap_pseudo_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_pseudo_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_pseudo_header))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_packet_header {
    pub caplen: guint32,
    pub len: guint32,
    pub pkt_encap: ::std::os::raw::c_int,
    pub interface_id: guint32,
    pub drop_count: guint64,
    pub pack_flags: guint32,
    pub interface_queue: guint32,
    pub packet_id: guint64,
    pub pseudo_header: wtap_pseudo_header,
}
#[test]
fn bindgen_test_layout_wtap_packet_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_packet_header>(),
        192usize,
        concat!("Size of: ", stringify!(wtap_packet_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_packet_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_packet_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).caplen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(caplen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).pkt_encap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(pkt_encap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).interface_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(interface_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).drop_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(drop_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).pack_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(pack_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_packet_header>())).interface_queue as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(interface_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_packet_header>())).packet_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_packet_header>())).pseudo_header as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_packet_header),
            "::",
            stringify!(pseudo_header)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_ft_specific_header {
    pub record_type: guint,
    pub record_len: guint32,
}
#[test]
fn bindgen_test_layout_wtap_ft_specific_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_ft_specific_header>(),
        8usize,
        concat!("Size of: ", stringify!(wtap_ft_specific_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_ft_specific_header>(),
        4usize,
        concat!("Alignment of ", stringify!(wtap_ft_specific_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_ft_specific_header>())).record_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_ft_specific_header),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_ft_specific_header>())).record_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_ft_specific_header),
            "::",
            stringify!(record_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_syscall_header {
    pub record_type: guint,
    pub byte_order: ::std::os::raw::c_int,
    pub timestamp: guint64,
    pub thread_id: guint64,
    pub event_len: guint32,
    pub event_filelen: guint32,
    pub event_type: guint16,
    pub cpu_id: guint16,
}
#[test]
fn bindgen_test_layout_wtap_syscall_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_syscall_header>(),
        40usize,
        concat!("Size of: ", stringify!(wtap_syscall_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_syscall_header>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_syscall_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).record_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).byte_order as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).thread_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).event_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_syscall_header>())).event_filelen as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_filelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).event_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_syscall_header>())).cpu_id as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_syscall_header),
            "::",
            stringify!(cpu_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_systemd_journal_header {
    pub record_len: guint32,
}
#[test]
fn bindgen_test_layout_wtap_systemd_journal_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_systemd_journal_header>(),
        4usize,
        concat!("Size of: ", stringify!(wtap_systemd_journal_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_systemd_journal_header>(),
        4usize,
        concat!("Alignment of ", stringify!(wtap_systemd_journal_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_systemd_journal_header>())).record_len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_systemd_journal_header),
            "::",
            stringify!(record_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_rec {
    pub rec_type: guint,
    pub presence_flags: guint32,
    pub ts: nstime_t,
    pub tsprec: ::std::os::raw::c_int,
    pub rec_header: wtap_rec__bindgen_ty_1,
    pub opt_comment: *mut gchar,
    pub has_comment_changed: gboolean,
    pub packet_verdict: *mut GPtrArray,
    pub options_buf: Buffer,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_rec__bindgen_ty_1 {
    pub packet_header: wtap_packet_header,
    pub ft_specific_header: wtap_ft_specific_header,
    pub syscall_header: wtap_syscall_header,
    pub systemd_journal_header: wtap_systemd_journal_header,
    _bindgen_union_align: [u64; 24usize],
}
#[test]
fn bindgen_test_layout_wtap_rec__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wtap_rec__bindgen_ty_1>(),
        192usize,
        concat!("Size of: ", stringify!(wtap_rec__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_rec__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_rec__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).packet_header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(packet_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).ft_specific_header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(ft_specific_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).syscall_header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(syscall_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wtap_rec__bindgen_ty_1>())).systemd_journal_header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec__bindgen_ty_1),
            "::",
            stringify!(systemd_journal_header)
        )
    );
}
#[test]
fn bindgen_test_layout_wtap_rec() {
    assert_eq!(
        ::std::mem::size_of::<wtap_rec>(),
        280usize,
        concat!("Size of: ", stringify!(wtap_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(wtap_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).rec_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(rec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).presence_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).ts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).tsprec as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(tsprec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).rec_header as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(rec_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).opt_comment as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(opt_comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).has_comment_changed as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(has_comment_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).packet_verdict as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(packet_verdict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wtap_rec>())).options_buf as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(wtap_rec),
            "::",
            stringify!(options_buf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
pub type frame_data = [u64; 11usize];
pub type address = [u64; 3usize];
pub const PT_NONE: port_type = 0;
pub const PT_SCTP: port_type = 1;
pub const PT_TCP: port_type = 2;
pub const PT_UDP: port_type = 3;
pub const PT_DCCP: port_type = 4;
pub const PT_IPX: port_type = 5;
pub const PT_DDP: port_type = 6;
pub const PT_IDP: port_type = 7;
pub const PT_USB: port_type = 8;
pub const PT_I2C: port_type = 9;
pub const PT_IBQP: port_type = 10;
pub const PT_BLUETOOTH: port_type = 11;
pub type port_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct endpoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    #[doc = "< name of protocol currently being dissected"]
    pub current_proto: *const ::std::os::raw::c_char,
    #[doc = "< Column formatting information"]
    pub cinfo: *mut epan_column_info,
    #[doc = "< Presence flags for some items"]
    pub presence_flags: guint32,
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet absolute time stamp"]
    pub abs_ts: nstime_t,
    #[doc = "< Relative timestamp (yes, it can be negative)"]
    pub rel_ts: nstime_t,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    #[doc = "< Record metadata"]
    pub rec: *mut wtap_rec,
    #[doc = "< Frame data sources"]
    pub data_src: *mut GSList,
    #[doc = "< link-layer source address"]
    pub dl_src: address,
    #[doc = "< link-layer destination address"]
    pub dl_dst: address,
    #[doc = "< network-layer source address"]
    pub net_src: address,
    #[doc = "< network-layer destination address"]
    pub net_dst: address,
    #[doc = "< source address (net if present, DL otherwise )"]
    pub src: address,
    #[doc = "< destination address (net if present, DL otherwise )"]
    pub dst: address,
    #[doc = "< First encountered VLAN Id if present otherwise 0"]
    pub vlan_id: guint32,
    #[doc = "< reason why reassembly wasn't done, if any"]
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if the protocol is only a fragment"]
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    #[doc = "< type of the following two port numbers"]
    pub ptype: port_type,
    #[doc = "< source port"]
    pub srcport: guint32,
    #[doc = "< destination port"]
    pub destport: guint32,
    #[doc = "< matched uint for calling subdissector from table"]
    pub match_uint: guint32,
    #[doc = "< matched string for calling subdissector from table"]
    pub match_string: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if endpoint member should be used for conversations"]
    pub use_endpoint: gboolean,
    #[doc = "< Data that can be used for conversations"]
    pub conv_endpoint: *mut endpoint,
    #[doc = "< >0 if this segment could be desegmented."]
    #[doc = "A dissector that can offer this API (e.g."]
    #[doc = "TCP) sets can_desegment=2, then"]
    #[doc = "can_desegment is decremented by 1 each time"]
    #[doc = "we pass to the next subdissector. Thus only"]
    #[doc = "the dissector immediately above the"]
    #[doc = "protocol which sets the flag can use it"]
    pub can_desegment: guint16,
    #[doc = "< Value of can_desegment before current"]
    #[doc = "dissector was called.  Supplied so that"]
    #[doc = "dissectors for proxy protocols such as"]
    #[doc = "SOCKS can restore it, allowing the"]
    #[doc = "dissectors that they call to use the"]
    #[doc = "TCP dissector's desegmentation (SOCKS"]
    #[doc = "just retransmits TCP segments once it's"]
    #[doc = "finished setting things up, so the TCP"]
    #[doc = "desegmentor can desegment its payload)."]
    pub saved_can_desegment: guint16,
    #[doc = "< offset to stuff needing desegmentation"]
    pub desegment_offset: ::std::os::raw::c_int,
    #[doc = "< requested desegmentation additional length"]
    #[doc = "or"]
    #[doc = "DESEGMENT_ONE_MORE_SEGMENT:"]
    #[doc = "Desegment one more full segment"]
    #[doc = "(warning! only partially implemented)"]
    #[doc = "DESEGMENT_UNTIL_FIN:"]
    #[doc = "Desgment all data for this tcp session"]
    #[doc = "until the FIN segment."]
    pub desegment_len: guint32,
    #[doc = "< >0 if the subdissector has specified"]
    #[doc = "a value in 'bytes_until_next_pdu'."]
    #[doc = "When a dissector detects that the next PDU"]
    #[doc = "will start beyond the start of the next"]
    #[doc = "segment, it can set this value to 2"]
    #[doc = "and 'bytes_until_next_pdu' to the number of"]
    #[doc = "bytes beyond the next segment where the"]
    #[doc = "next PDU starts."]
    #[doc = ""]
    #[doc = "If the protocol dissector below this"]
    #[doc = "one is capable of PDU tracking it can"]
    #[doc = "use this hint to detect PDUs that starts"]
    #[doc = "unaligned to the segment boundaries."]
    #[doc = "The TCP dissector is using this hint from"]
    #[doc = "(some) protocols to detect when a new PDU"]
    #[doc = "starts in the middle of a tcp segment."]
    #[doc = ""]
    #[doc = "There is intelligence in the glue between"]
    #[doc = "dissector layers to make sure that this"]
    #[doc = "request is only passed down to the protocol"]
    #[doc = "immediately below the current one and not"]
    #[doc = "any further."]
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    #[doc = "< Packet was captured as an"]
    #[doc = "outbound (P2P_DIR_SENT)"]
    #[doc = "inbound (P2P_DIR_RECV)"]
    #[doc = "unknown (P2P_DIR_UNKNOWN)"]
    pub p2p_dir: ::std::os::raw::c_int,
    #[doc = "< a hash table passed from one dissector to another"]
    pub private_table: *mut GHashTable,
    #[doc = "< layers of each protocol"]
    pub layers: *mut wmem_list_t,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub curr_layer_num: guint8,
    pub link_number: guint16,
    #[doc = "< clnp/cotp source reference (can't use srcport, this would confuse tpkt)"]
    pub clnp_srcref: guint16,
    #[doc = "< clnp/cotp destination reference (can't use dstport, this would confuse tpkt)"]
    pub clnp_dstref: guint16,
    #[doc = "< 3GPP messages are sometime different UP link(UL) or Downlink(DL)"]
    pub link_dir: ::std::os::raw::c_int,
    #[doc = "< Per packet proto data"]
    pub proto_data: *mut GSList,
    #[doc = "< A list of frames which this one depends on"]
    pub dependent_frames: *mut GSList,
    pub frame_end_routines: *mut GSList,
    #[doc = "< Memory pool scoped to the pinfo struct"]
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    #[doc = "< name of heur list if this packet is being heuristically dissected"]
    pub heur_list_name: *const gchar,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__packet_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_packet_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_packet_info__bindgen_ty_1))
    );
}
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__packet_info() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info>(),
        400usize,
        concat!("Size of: ", stringify!(_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_packet_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).current_proto as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(current_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).cinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(cinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).presence_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).num as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).abs_ts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(abs_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).rel_ts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).fd as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).pseudo_header as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pseudo_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).rec as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).data_src as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(data_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dl_src as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dl_dst as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).net_src as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).net_dst as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).src as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dst as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).vlan_id as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).noreassembly_reason as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(noreassembly_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).fragmented as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fragmented)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).flags as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).ptype as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(ptype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).srcport as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(srcport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).destport as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(destport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).match_uint as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).match_string as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).use_endpoint as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(use_endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).conv_endpoint as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).can_desegment as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(can_desegment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).saved_can_desegment as *const _ as usize
        },
        298usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(saved_can_desegment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).desegment_offset as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).desegment_len as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).want_pdu_tracking as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(want_pdu_tracking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).bytes_until_next_pdu as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(bytes_until_next_pdu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).p2p_dir as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(p2p_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).private_table as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(private_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).layers as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).curr_layer_num as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_layer_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).link_number as *const _ as usize },
        338usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).clnp_srcref as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_srcref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).clnp_dstref as *const _ as usize },
        342usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_dstref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).link_dir as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).proto_data as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dependent_frames as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dependent_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).frame_end_routines as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(frame_end_routines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).pool as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).epan as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(epan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).heur_list_name as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(heur_list_name)
        )
    );
}
pub type packet_info = _packet_info;
pub const FT_NONE: ftenum = 0;
pub const FT_PROTOCOL: ftenum = 1;
pub const FT_BOOLEAN: ftenum = 2;
pub const FT_CHAR: ftenum = 3;
pub const FT_UINT8: ftenum = 4;
pub const FT_UINT16: ftenum = 5;
pub const FT_UINT24: ftenum = 6;
pub const FT_UINT32: ftenum = 7;
pub const FT_UINT40: ftenum = 8;
pub const FT_UINT48: ftenum = 9;
pub const FT_UINT56: ftenum = 10;
pub const FT_UINT64: ftenum = 11;
pub const FT_INT8: ftenum = 12;
pub const FT_INT16: ftenum = 13;
pub const FT_INT24: ftenum = 14;
pub const FT_INT32: ftenum = 15;
pub const FT_INT40: ftenum = 16;
pub const FT_INT48: ftenum = 17;
pub const FT_INT56: ftenum = 18;
pub const FT_INT64: ftenum = 19;
pub const FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const FT_IEEE_11073_FLOAT: ftenum = 21;
pub const FT_FLOAT: ftenum = 22;
pub const FT_DOUBLE: ftenum = 23;
pub const FT_ABSOLUTE_TIME: ftenum = 24;
pub const FT_RELATIVE_TIME: ftenum = 25;
pub const FT_STRING: ftenum = 26;
pub const FT_STRINGZ: ftenum = 27;
pub const FT_UINT_STRING: ftenum = 28;
pub const FT_ETHER: ftenum = 29;
pub const FT_BYTES: ftenum = 30;
pub const FT_UINT_BYTES: ftenum = 31;
pub const FT_IPv4: ftenum = 32;
pub const FT_IPv6: ftenum = 33;
pub const FT_IPXNET: ftenum = 34;
pub const FT_FRAMENUM: ftenum = 35;
pub const FT_PCRE: ftenum = 36;
pub const FT_GUID: ftenum = 37;
pub const FT_OID: ftenum = 38;
pub const FT_EUI64: ftenum = 39;
pub const FT_AX25: ftenum = 40;
pub const FT_VINES: ftenum = 41;
pub const FT_REL_OID: ftenum = 42;
pub const FT_SYSTEM_ID: ftenum = 43;
pub const FT_STRINGZPAD: ftenum = 44;
pub const FT_FCWWN: ftenum = 45;
pub const FT_STRINGZTRUNC: ftenum = 46;
pub const FT_NUM_TYPES: ftenum = 47;
pub type ftenum = ::std::os::raw::c_uint;
#[doc = "< none"]
pub const BASE_NONE: field_display_e = 0;
#[doc = "< decimal"]
pub const BASE_DEC: field_display_e = 1;
#[doc = "< hexadecimal"]
pub const BASE_HEX: field_display_e = 2;
#[doc = "< octal"]
pub const BASE_OCT: field_display_e = 3;
#[doc = "< decimal (hexadecimal)"]
pub const BASE_DEC_HEX: field_display_e = 4;
#[doc = "< hexadecimal (decimal)"]
pub const BASE_HEX_DEC: field_display_e = 5;
#[doc = "< call custom routine (in ->strings) to format"]
pub const BASE_CUSTOM: field_display_e = 6;
#[doc = "< decimal-format float"]
pub const BASE_FLOAT: field_display_e = 0;
#[doc = "< shows non-printable ASCII characters as C-style escapes"]
pub const STR_ASCII: field_display_e = 0;
#[doc = "< shows non-printable UNICODE characters as \\\\uXXXX (XXX for now non-printable characters display depends on UI)"]
pub const STR_UNICODE: field_display_e = 7;
#[doc = "< hexadecimal bytes with a period (.) between each byte"]
pub const SEP_DOT: field_display_e = 8;
#[doc = "< hexadecimal bytes with a dash (-) between each byte"]
pub const SEP_DASH: field_display_e = 9;
#[doc = "< hexadecimal bytes with a colon (:) between each byte"]
pub const SEP_COLON: field_display_e = 10;
#[doc = "< hexadecimal bytes with a space between each byte"]
pub const SEP_SPACE: field_display_e = 11;
#[doc = "< Used for IPv4 address that shouldn't be resolved (like for netmasks)"]
pub const BASE_NETMASK: field_display_e = 12;
#[doc = "< UDP port"]
pub const BASE_PT_UDP: field_display_e = 13;
#[doc = "< TCP port"]
pub const BASE_PT_TCP: field_display_e = 14;
#[doc = "< DCCP port"]
pub const BASE_PT_DCCP: field_display_e = 15;
#[doc = "< SCTP port"]
pub const BASE_PT_SCTP: field_display_e = 16;
#[doc = "< OUI resolution"]
pub const BASE_OUI: field_display_e = 17;
pub type field_display_e = ::std::os::raw::c_uint;
#[doc = "< Field is not referenced"]
pub const HF_REF_TYPE_NONE: hf_ref_type = 0;
#[doc = "< Field is indirectly referenced (only applicable for FT_PROTOCOL) via. its child"]
pub const HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
#[doc = "< Field is directly referenced"]
pub const HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = ::std::os::raw::c_uint;
#[doc = " information describing a header field"]
pub type header_field_info = _header_field_info;
#[doc = " information describing a header field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    #[doc = "< [FIELDNAME] full name of this field"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDABBREV] abbreviated name of this field"]
    pub abbrev: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDTYPE] field type, one of FT_ (from ftypes.h)"]
    pub type_: ftenum,
    #[doc = "< [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask"]
    pub display: ::std::os::raw::c_int,
    #[doc = "< [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,"]
    #[doc = "typically converted by VALS(), RVALS() or TFS()."]
    #[doc = "If this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the"]
    #[doc = "associated protocol_t structure"]
    pub strings: *const ::std::os::raw::c_void,
    #[doc = "< [BITMASK] bitmask of interesting bits"]
    pub bitmask: guint64,
    #[doc = "< [FIELDDESCR] Brief description of field"]
    pub blurb: *const ::std::os::raw::c_char,
    #[doc = "< Field ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< parent protocol tree"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "< is this field referenced by a filter"]
    pub ref_type: hf_ref_type,
    #[doc = "< ID of previous hfinfo with same abbrev"]
    pub same_name_prev_id: ::std::os::raw::c_int,
    #[doc = "< Link to next hfinfo with same abbrev"]
    pub same_name_next: *mut header_field_info,
}
#[test]
fn bindgen_test_layout__header_field_info() {
    assert_eq!(
        ::std::mem::size_of::<_header_field_info>(),
        72usize,
        concat!("Size of: ", stringify!(_header_field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_header_field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_header_field_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).abbrev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(abbrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).display as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).strings as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).bitmask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(bitmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).blurb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(blurb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).parent as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).ref_type as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(ref_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_header_field_info>())).same_name_prev_id as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_prev_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_header_field_info>())).same_name_next as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_next)
        )
    );
}
#[doc = " Used when registering many fields at once, using proto_register_field_array()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hf_register_info {
    #[doc = "< written to by register() function"]
    pub p_id: *mut ::std::os::raw::c_int,
    #[doc = "< the field info to be registered"]
    pub hfinfo: header_field_info,
}
#[test]
fn bindgen_test_layout_hf_register_info() {
    assert_eq!(
        ::std::mem::size_of::<hf_register_info>(),
        80usize,
        concat!("Size of: ", stringify!(hf_register_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hf_register_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hf_register_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hf_register_info>())).p_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(p_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hf_register_info>())).hfinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(hfinfo)
        )
    );
}
#[doc = " A protocol tree element."]
pub type proto_tree = [u64; 6usize];
#[doc = " A protocol item element."]
pub type proto_item = [u64; 6usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_plugin {
    pub register_protoinfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_handoff: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_proto_plugin() {
    assert_eq!(
        ::std::mem::size_of::<proto_plugin>(),
        16usize,
        concat!("Size of: ", stringify!(proto_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<proto_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(proto_plugin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proto_plugin>())).register_protoinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_protoinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proto_plugin>())).register_handoff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_handoff)
        )
    );
}
extern "C" {
    #[doc = " Register dissector plugin with the plugin system."]
    pub fn proto_register_plugin(plugin: *const proto_plugin);
}
extern "C" {
    #[doc = " Create a subtree under an existing item."]
    #[doc = "@param pi the parent item of the new subtree"]
    #[doc = "@param idx one of the ett_ array elements registered with proto_register_subtree_array()"]
    #[doc = "@return the new subtree"]
    pub fn proto_item_add_subtree(pi: *mut proto_item, idx: gint) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Replace text of item after it already has been created."]
    #[doc = "@param pi the item to set the text"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    pub fn proto_item_set_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Append to text of item after it has already been created."]
    #[doc = "@param pi the item to append the text to"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    pub fn proto_item_append_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn proto_tree_add_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_NONE field to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_none_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree like proto_tree_add_bytes,"]
    #[doc = "but used when the tvb data length does not match the bytes length."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param ptr_length length of data in start_ptr"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_with_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        ptr_length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get and add a byte-array-based FT_* to a proto_tree."]
    #[doc = ""]
    #[doc = "Supported: FT_BYTES, FT_UINT_BYTES, FT_OID, FT_REL_OID, and FT_SYSTEM_ID."]
    #[doc = ""]
    #[doc = "The item is extracted from the tvbuff handed to it, based on the ENC_* passed"]
    #[doc = "in for the encoding, and the retrieved byte array is also set to *retval so the"]
    #[doc = "caller gets it back for other uses."]
    #[doc = ""]
    #[doc = "This function retrieves the value even if the passed-in tree param is NULL,"]
    #[doc = "so that it can be used by dissectors at all times to both get the value"]
    #[doc = "and set the tree item to it."]
    #[doc = ""]
    #[doc = "Like other proto_tree_add functions, if there is a tree and the value cannot"]
    #[doc = "be decoded from the tvbuff, then an expert info error is reported. For string"]
    #[doc = "encoding, this means that a failure to decode the hex value from the string"]
    #[doc = "results in an expert info error being added to the tree."]
    #[doc = ""]
    #[doc = "If encoding is string-based, it will convert using tvb_get_string_bytes(); see"]
    #[doc = "that function's comments for details."]
    #[doc = ""]
    #[doc = "@note The GByteArray retval must be pre-constructed using g_byte_array_new()."]
    #[doc = ""]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, or ENC_UTF_8|ENC_STR_HEX)"]
    #[doc = "@param[in,out] retval points to a GByteArray which will be set to the bytes from the Tvb."]
    #[doc = "@param[in,out] endoff if not NULL, gets set to the character after those consumed."]
    #[doc = "@param[in,out] err if not NULL, gets set to 0 if no failure, else the errno code (e.g., EDOM, ERANGE)."]
    #[doc = "@return the newly created item, and retval is set to the decoded value"]
    pub fn proto_tree_add_bytes_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut GByteArray,
        endoff: *mut gint,
        err: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_GUID to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC to a"]
    #[doc = "proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC"]
    #[doc = "to a proto_tree, with the format generating the string for the value"]
    #[doc = "and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC"]
    #[doc = "to a proto_tree, with the format generating the entire string for the"]
    #[doc = "entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BOOLEAN to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_FLOAT to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,"]
    #[doc = "with the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,"]
    #[doc = "with the format generating the entire string for the entry, including any"]
    #[doc = "field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_UINT64 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,"]
    #[doc = "with the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,"]
    #[doc = "with the format generating the entire string for the entry, including"]
    #[doc = "any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_INT64 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Register a new protocol."]
    #[doc = "@param name the full name of the new protocol"]
    #[doc = "@param short_name abbreviated name of the new protocol"]
    #[doc = "@param filter_name protocol name used for a display filter string"]
    #[doc = "@return the new protocol handle"]
    pub fn proto_register_protocol(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a header_field array."]
    #[doc = "@param parent the protocol handle from proto_register_protocol()"]
    #[doc = "@param hf the hf_register_info array"]
    #[doc = "@param num_records the number of records in hf"]
    pub fn proto_register_field_array(
        parent: ::std::os::raw::c_int,
        hf: *mut hf_register_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Register a protocol subtree (ett) array."]
    #[doc = "@param indices array of ett indices"]
    #[doc = "@param num_indices the number of records in indices"]
    pub fn proto_register_subtree_array(
        indices: *const *mut gint,
        num_indices: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with"]
    #[doc = "the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with"]
    #[doc = "the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value64(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_FLOAT header field to a proto_tree, with"]
    #[doc = "the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[doc = "  Helper routines for column utility structures and routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
pub type column_info = epan_column_info;
#[doc = "< 0) 802.1Q vlan ID"]
pub const COL_8021Q_VLAN_ID: ::std::os::raw::c_uint = 0;
#[doc = "< 1) Absolute date, as YYYY-MM-DD, and time"]
pub const COL_ABS_YMD_TIME: ::std::os::raw::c_uint = 1;
#[doc = "< 2) Absolute date, as YYYY/DOY, and time"]
pub const COL_ABS_YDOY_TIME: ::std::os::raw::c_uint = 2;
#[doc = "< 3) Absolute time"]
pub const COL_ABS_TIME: ::std::os::raw::c_uint = 3;
#[doc = "< 4) VSAN - Cisco MDS-specific"]
pub const COL_VSAN: ::std::os::raw::c_uint = 4;
#[doc = "< 5) Cumulative number of bytes"]
pub const COL_CUMULATIVE_BYTES: ::std::os::raw::c_uint = 5;
#[doc = "< 6) Custom column (any filter name's contents)"]
pub const COL_CUSTOM: ::std::os::raw::c_uint = 6;
#[doc = "< 7) DCE/RPC connection oriented call id OR datagram sequence number"]
pub const COL_DCE_CALL: ::std::os::raw::c_uint = 7;
#[doc = "< 8) Delta time"]
pub const COL_DELTA_TIME: ::std::os::raw::c_uint = 8;
#[doc = "< 9) Delta time displayed"]
pub const COL_DELTA_TIME_DIS: ::std::os::raw::c_uint = 9;
#[doc = "< 10) Resolved dest"]
pub const COL_RES_DST: ::std::os::raw::c_uint = 10;
#[doc = "< 11) Unresolved dest"]
pub const COL_UNRES_DST: ::std::os::raw::c_uint = 11;
#[doc = "< 12) Resolved dest port"]
pub const COL_RES_DST_PORT: ::std::os::raw::c_uint = 12;
#[doc = "< 13) Unresolved dest port"]
pub const COL_UNRES_DST_PORT: ::std::os::raw::c_uint = 13;
#[doc = "< 14) Destination address"]
pub const COL_DEF_DST: ::std::os::raw::c_uint = 14;
#[doc = "< 15) Destination port"]
pub const COL_DEF_DST_PORT: ::std::os::raw::c_uint = 15;
#[doc = "< 16) Expert Info"]
pub const COL_EXPERT: ::std::os::raw::c_uint = 16;
#[doc = "< 17) FW-1 monitor interface/direction"]
pub const COL_IF_DIR: ::std::os::raw::c_uint = 17;
#[doc = "< 18) IEEE 802.11 (and WiMax?) - Channel"]
pub const COL_FREQ_CHAN: ::std::os::raw::c_uint = 18;
#[doc = "< 19) Data link layer dest address"]
pub const COL_DEF_DL_DST: ::std::os::raw::c_uint = 19;
#[doc = "< 20) Data link layer source address"]
pub const COL_DEF_DL_SRC: ::std::os::raw::c_uint = 20;
#[doc = "< 21) Resolved DL dest"]
pub const COL_RES_DL_DST: ::std::os::raw::c_uint = 21;
#[doc = "< 22) Unresolved DL dest"]
pub const COL_UNRES_DL_DST: ::std::os::raw::c_uint = 22;
#[doc = "< 23) Resolved DL source"]
pub const COL_RES_DL_SRC: ::std::os::raw::c_uint = 23;
#[doc = "< 24) Unresolved DL source"]
pub const COL_UNRES_DL_SRC: ::std::os::raw::c_uint = 24;
#[doc = "< 25) IEEE 802.11 - received signal strength"]
pub const COL_RSSI: ::std::os::raw::c_uint = 25;
#[doc = "< 26) IEEE 802.11 - TX rate in Mbps"]
pub const COL_TX_RATE: ::std::os::raw::c_uint = 26;
#[doc = "< 27) IP DSCP Value"]
pub const COL_DSCP_VALUE: ::std::os::raw::c_uint = 27;
#[doc = "< 28) Description"]
pub const COL_INFO: ::std::os::raw::c_uint = 28;
#[doc = "< 29) Resolved net dest"]
pub const COL_RES_NET_DST: ::std::os::raw::c_uint = 29;
#[doc = "< 30) Unresolved net dest"]
pub const COL_UNRES_NET_DST: ::std::os::raw::c_uint = 30;
#[doc = "< 31) Resolved net source"]
pub const COL_RES_NET_SRC: ::std::os::raw::c_uint = 31;
#[doc = "< 32) Unresolved net source"]
pub const COL_UNRES_NET_SRC: ::std::os::raw::c_uint = 32;
#[doc = "< 33) Network layer dest address"]
pub const COL_DEF_NET_DST: ::std::os::raw::c_uint = 33;
#[doc = "< 34) Network layer source address"]
pub const COL_DEF_NET_SRC: ::std::os::raw::c_uint = 34;
#[doc = "< 35) Packet list item number"]
pub const COL_NUMBER: ::std::os::raw::c_uint = 35;
#[doc = "< 36) Packet length in bytes"]
pub const COL_PACKET_LENGTH: ::std::os::raw::c_uint = 36;
#[doc = "< 37) Protocol"]
pub const COL_PROTOCOL: ::std::os::raw::c_uint = 37;
#[doc = "< 38) Relative time"]
pub const COL_REL_TIME: ::std::os::raw::c_uint = 38;
#[doc = "< 39) Source address"]
pub const COL_DEF_SRC: ::std::os::raw::c_uint = 39;
#[doc = "< 40) Source port"]
pub const COL_DEF_SRC_PORT: ::std::os::raw::c_uint = 40;
#[doc = "< 41) Resolved source"]
pub const COL_RES_SRC: ::std::os::raw::c_uint = 41;
#[doc = "< 42) Unresolved source"]
pub const COL_UNRES_SRC: ::std::os::raw::c_uint = 42;
#[doc = "< 43) Resolved source port"]
pub const COL_RES_SRC_PORT: ::std::os::raw::c_uint = 43;
#[doc = "< 44) Unresolved source port"]
pub const COL_UNRES_SRC_PORT: ::std::os::raw::c_uint = 44;
#[doc = "< 45) Q.921 TEI"]
pub const COL_TEI: ::std::os::raw::c_uint = 45;
#[doc = "< 46) UTC date, as YYYY-MM-DD, and time"]
pub const COL_UTC_YMD_TIME: ::std::os::raw::c_uint = 46;
#[doc = "< 47) UTC date, as YYYY/DOY, and time"]
pub const COL_UTC_YDOY_TIME: ::std::os::raw::c_uint = 47;
#[doc = "< 48) UTC time"]
pub const COL_UTC_TIME: ::std::os::raw::c_uint = 48;
#[doc = "< 49) Command line-specified time (default relative)"]
pub const COL_CLS_TIME: ::std::os::raw::c_uint = 49;
#[doc = "< 50) Should always be last"]
pub const NUM_COL_FMTS: ::std::os::raw::c_uint = 50;
#[doc = " All of the possible columns in summary listing."]
#[doc = ""]
#[doc = " NOTE1: The entries MUST remain in this order, or else you need to reorder"]
#[doc = "        the slist[] and dlist[] arrays in column.c to match!"]
#[doc = ""]
#[doc = " NOTE2: Please add the COL_XYZ entry in the appropriate spot, such that the"]
#[doc = "        dlist[] array remains in alphabetical order!"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Clears the text of a column element."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Set (replace) the text of a column element, the text won't be copied."]
    #[doc = ""]
    #[doc = " Usually used to set const strings!"]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param str the string to set"]
    pub fn col_set_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
extern "C" {
    #[doc = " Add (replace) the text of a column element, the text will be copied."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param str the string to add"]
    pub fn col_add_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
pub type dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn dissector_add_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    #[doc = " Create an anonymous handle for a dissector."]
    pub fn create_dissector_handle(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn add_new_data_source(
        pinfo: *mut packet_info,
        tvb: *mut tvbuff_t,
        name: *const ::std::os::raw::c_char,
    );
}

#![allow(bad_style)]
/* automatically generated by rust-bindgen 0.69.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const ENC_BIG_ENDIAN: u32 = 0;
pub const ENC_NA: u32 = 0;
pub const FI_HIDDEN: u32 = 1;
pub type __time_t = i64;
pub type guint8 = u8;
pub type gint16 = i16;
pub type guint16 = u16;
pub type gint32 = i32;
pub type guint32 = u32;
pub type guint64 = u64;
pub type time_t = __time_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type GHashTable = u8;
pub type GSList = [u64; 2usize];
#[doc = " A public opaque type representing one wmem allocation pool."]
pub type wmem_allocator_t = u8;
#[cfg_attr(windows, link(name = "libwsutil", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Allocate the requested amount of memory in the given pool.\n\n @param allocator The allocator object to use to allocate the memory.\n @param size The amount of memory to allocate.\n @return A void pointer to the newly allocated memory."]
    pub fn wmem_alloc(allocator: *mut wmem_allocator_t, size: usize)
        -> *mut ::std::os::raw::c_void;
}
pub type wmem_list_t = u8;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-map Hash Map\n\n    A hash map implementation on top of wmem. Provides insertion, deletion and\n    lookup in expected amortized constant time. Uses universal hashing to map\n    keys into buckets, and provides a generic strong hash function that makes\n    it secure against algorithmic complexity attacks, and suitable for use\n    even with untrusted data.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_map_t {
    _unused: [u8; 0],
}
pub type wmem_map_t = _wmem_map_t;
#[doc = " @addtogroup wmem\n  @{\n    @defgroup wmem-tree Red/Black Tree\n\n    Binary trees are a well-known and popular device in computer science to\n    handle storage of objects based on a search key or identity. The\n    particular binary tree style implemented here is the red/black tree, which\n    has the nice property of being self-balancing. This guarantees O(log(n))\n    time for lookups, compared to linked lists that are O(n). This means\n    red/black trees scale very well when many objects are being stored.\n\n    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_tree_t {
    _unused: [u8; 0],
}
pub type wmem_tree_t = _wmem_tree_t;
#[doc = " data structure to hold time values with nanosecond resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nstime_t() {
    const UNINIT: ::std::mem::MaybeUninit<nstime_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nstime_t>(),
        16usize,
        concat!("Size of: ", stringify!(nstime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nstime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nstime_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsecs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(nsecs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_guid_t {
    pub data1: guint32,
    pub data2: guint16,
    pub data3: guint16,
    pub data4: [guint8; 8usize],
}
#[test]
fn bindgen_test_layout__e_guid_t() {
    const UNINIT: ::std::mem::MaybeUninit<_e_guid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_e_guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_e_guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_e_guid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_e_guid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_e_guid_t),
            "::",
            stringify!(data4)
        )
    );
}
pub type e_guid_t = _e_guid_t;
pub type tvbuff_t = u8;
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn tvb_new_child_real_data(
        parent: *mut tvbuff_t,
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Similar to tvb_new_subset_length_caplen() but with backing_length and reported_length set\n to -1.  Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_remaining(backing: *mut tvbuff_t, backing_offset: gint) -> *mut tvbuff_t;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn tvb_reported_length(tvb: *const tvbuff_t) -> guint;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Returns target for convenience. Does not suffer from possible\n expense of tvb_get_ptr(), since this routine is smart enough\n to copy data in chunks if the request range actually exists in\n different \"real\" tvbuffs. This function assumes that the target\n memory is already allocated; it does not allocate or free the\n target memory."]
    pub fn tvb_memcpy(
        tvb: *mut tvbuff_t,
        target: *mut ::std::os::raw::c_void,
        offset: gint,
        length: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_rec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
pub type frame_data = [u64; 13usize];
pub type address = [u64; 3usize];
pub const PT_NONE: port_type = 0;
pub const PT_SCTP: port_type = 1;
pub const PT_TCP: port_type = 2;
pub const PT_UDP: port_type = 3;
pub const PT_DCCP: port_type = 4;
pub const PT_IPX: port_type = 5;
pub const PT_DDP: port_type = 6;
pub const PT_IDP: port_type = 7;
pub const PT_USB: port_type = 8;
pub const PT_I2C: port_type = 9;
pub const PT_IBQP: port_type = 10;
pub const PT_BLUETOOTH: port_type = 11;
pub const PT_IWARP_MPA: port_type = 12;
pub const PT_MCTP: port_type = 13;
pub type port_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    #[doc = "< name of protocol currently being dissected"]
    pub current_proto: *const ::std::os::raw::c_char,
    #[doc = "< Column formatting information"]
    pub cinfo: *mut epan_column_info,
    #[doc = "< Presence flags for some items"]
    pub presence_flags: guint32,
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet absolute time stamp"]
    pub abs_ts: nstime_t,
    #[doc = "< Relative timestamp (yes, it can be negative)"]
    pub rel_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start (might be negative for broken files)"]
    pub rel_cap_ts: nstime_t,
    #[doc = "< Relative timestamp from capture start valid"]
    pub rel_cap_ts_present: gboolean,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    #[doc = "< Record metadata"]
    pub rec: *mut wtap_rec,
    #[doc = "< Frame data sources"]
    pub data_src: *mut GSList,
    #[doc = "< link-layer source address"]
    pub dl_src: address,
    #[doc = "< link-layer destination address"]
    pub dl_dst: address,
    #[doc = "< network-layer source address"]
    pub net_src: address,
    #[doc = "< network-layer destination address"]
    pub net_dst: address,
    #[doc = "< source address (net if present, DL otherwise )"]
    pub src: address,
    #[doc = "< destination address (net if present, DL otherwise )"]
    pub dst: address,
    #[doc = "< First encountered VLAN Id if present otherwise 0"]
    pub vlan_id: guint32,
    #[doc = "< reason why reassembly wasn't done, if any"]
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if the protocol is only a fragment"]
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    #[doc = "< type of the following two port numbers"]
    pub ptype: port_type,
    #[doc = "< source port"]
    pub srcport: guint32,
    #[doc = "< destination port"]
    pub destport: guint32,
    #[doc = "< matched uint for calling subdissector from table"]
    pub match_uint: guint32,
    #[doc = "< matched string for calling subdissector from table"]
    pub match_string: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if address/port endpoints member should be used for conversations"]
    pub use_conv_addr_port_endpoints: gboolean,
    #[doc = "< Data that can be used for address+port conversations, including wildcarding"]
    pub conv_addr_port_endpoints: *mut conversation_addr_port_endpoints,
    #[doc = "< Arbritrary conversation identifier; can't be wildcarded"]
    pub conv_elements: *mut conversation_element,
    #[doc = "< >0 if this segment could be desegmented.\nA dissector that can offer this API (e.g.\nTCP) sets can_desegment=2, then\ncan_desegment is decremented by 1 each time\nwe pass to the next subdissector. Thus only\nthe dissector immediately above the\nprotocol which sets the flag can use it"]
    pub can_desegment: guint16,
    #[doc = "< Value of can_desegment before current\ndissector was called.  Supplied so that\ndissectors for proxy protocols such as\nSOCKS can restore it, allowing the\ndissectors that they call to use the\nTCP dissector's desegmentation (SOCKS\njust retransmits TCP segments once it's\nfinished setting things up, so the TCP\ndesegmentor can desegment its payload)."]
    pub saved_can_desegment: guint16,
    #[doc = "< offset to stuff needing desegmentation"]
    pub desegment_offset: ::std::os::raw::c_int,
    #[doc = "< requested desegmentation additional length\nor\nDESEGMENT_ONE_MORE_SEGMENT:\nDesegment one more full segment\n(warning! only partially implemented)\nDESEGMENT_UNTIL_FIN:\nDesgment all data for this tcp session\nuntil the FIN segment."]
    pub desegment_len: guint32,
    #[doc = "< >0 if the subdissector has specified\na value in 'bytes_until_next_pdu'.\nWhen a dissector detects that the next PDU\nwill start beyond the start of the next\nsegment, it can set this value to 2\nand 'bytes_until_next_pdu' to the number of\nbytes beyond the next segment where the\nnext PDU starts.\n\nIf the protocol dissector below this\none is capable of PDU tracking it can\nuse this hint to detect PDUs that starts\nunaligned to the segment boundaries.\nThe TCP dissector is using this hint from\n(some) protocols to detect when a new PDU\nstarts in the middle of a tcp segment.\n\nThere is intelligence in the glue between\ndissector layers to make sure that this\nrequest is only passed down to the protocol\nimmediately below the current one and not\nany further."]
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    #[doc = "< Packet was captured as an\noutbound (P2P_DIR_SENT)\ninbound (P2P_DIR_RECV)\nunknown (P2P_DIR_UNKNOWN)"]
    pub p2p_dir: ::std::os::raw::c_int,
    #[doc = "< a hash table passed from one dissector to another"]
    pub private_table: *mut GHashTable,
    #[doc = "< layers of each protocol"]
    pub layers: *mut wmem_list_t,
    pub proto_layers: *mut wmem_map_t,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub curr_layer_num: guint8,
    #[doc = "< The current \"depth\" or layer number for this dissector in the current frame"]
    pub curr_proto_layer_num: guint8,
    pub link_number: guint16,
    #[doc = "< clnp/cotp source reference (can't use srcport, this would confuse tpkt)"]
    pub clnp_srcref: guint16,
    #[doc = "< clnp/cotp destination reference (can't use dstport, this would confuse tpkt)"]
    pub clnp_dstref: guint16,
    #[doc = "< 3GPP messages are sometime different UP link(UL) or Downlink(DL)"]
    pub link_dir: ::std::os::raw::c_int,
    #[doc = "< Rcv.Wind.Shift src applies when sending segments; -1 unknown; -2 disabled"]
    pub src_win_scale: gint16,
    #[doc = "< Rcv.Wind.Shift dst applies when sending segments; -1 unknown; -2 disabled"]
    pub dst_win_scale: gint16,
    #[doc = "< Per packet proto data"]
    pub proto_data: *mut GSList,
    pub frame_end_routines: *mut GSList,
    #[doc = "< Memory pool scoped to the pinfo struct"]
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    #[doc = "< name of heur list if this packet is being heuristically dissected"]
    pub heur_list_name: *const gchar,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub dissection_depth: ::std::os::raw::c_int,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__packet_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_packet_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_packet_info__bindgen_ty_1))
    );
}
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__packet_info() {
    const UNINIT: ::std::mem::MaybeUninit<_packet_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_packet_info>(),
        440usize,
        concat!("Size of: ", stringify!(_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_packet_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_proto) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(current_proto)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(cinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presence_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abs_ts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(abs_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_ts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_cap_ts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_cap_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_cap_ts_present) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_cap_ts_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudo_header) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pseudo_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rec) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_src) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(data_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dl_src) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dl_dst) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net_src) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net_dst) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_id) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noreassembly_reason) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(noreassembly_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fragmented) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fragmented)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptype) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(ptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcport) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(srcport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destport) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(destport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_uint) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_uint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_string) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_string)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).use_conv_addr_port_endpoints) as usize - ptr as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(use_conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv_addr_port_endpoints) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_addr_port_endpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv_elements) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(conv_elements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_desegment) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(can_desegment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saved_can_desegment) as usize - ptr as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(saved_can_desegment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desegment_offset) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desegment_len) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_pdu_tracking) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(want_pdu_tracking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_until_next_pdu) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(bytes_until_next_pdu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p2p_dir) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(p2p_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_table) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(private_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layers) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_layers) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_layer_num) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curr_proto_layer_num) as usize - ptr as usize },
        377usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_proto_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_number) as usize - ptr as usize },
        378usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clnp_srcref) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_srcref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clnp_dstref) as usize - ptr as usize },
        382usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_dstref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_dir) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_win_scale) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src_win_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst_win_scale) as usize - ptr as usize },
        390usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst_win_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_data) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_end_routines) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(frame_end_routines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epan) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(epan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heur_list_name) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(heur_list_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dissection_depth) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dissection_depth)
        )
    );
}
pub type packet_info = _packet_info;
pub const FT_NONE: ftenum = 0;
pub const FT_PROTOCOL: ftenum = 1;
pub const FT_BOOLEAN: ftenum = 2;
pub const FT_CHAR: ftenum = 3;
pub const FT_UINT8: ftenum = 4;
pub const FT_UINT16: ftenum = 5;
pub const FT_UINT24: ftenum = 6;
pub const FT_UINT32: ftenum = 7;
pub const FT_UINT40: ftenum = 8;
pub const FT_UINT48: ftenum = 9;
pub const FT_UINT56: ftenum = 10;
pub const FT_UINT64: ftenum = 11;
pub const FT_INT8: ftenum = 12;
pub const FT_INT16: ftenum = 13;
pub const FT_INT24: ftenum = 14;
pub const FT_INT32: ftenum = 15;
pub const FT_INT40: ftenum = 16;
pub const FT_INT48: ftenum = 17;
pub const FT_INT56: ftenum = 18;
pub const FT_INT64: ftenum = 19;
pub const FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const FT_IEEE_11073_FLOAT: ftenum = 21;
pub const FT_FLOAT: ftenum = 22;
pub const FT_DOUBLE: ftenum = 23;
pub const FT_ABSOLUTE_TIME: ftenum = 24;
pub const FT_RELATIVE_TIME: ftenum = 25;
pub const FT_STRING: ftenum = 26;
pub const FT_STRINGZ: ftenum = 27;
pub const FT_UINT_STRING: ftenum = 28;
pub const FT_ETHER: ftenum = 29;
pub const FT_BYTES: ftenum = 30;
pub const FT_UINT_BYTES: ftenum = 31;
pub const FT_IPv4: ftenum = 32;
pub const FT_IPv6: ftenum = 33;
pub const FT_IPXNET: ftenum = 34;
pub const FT_FRAMENUM: ftenum = 35;
pub const FT_GUID: ftenum = 36;
pub const FT_OID: ftenum = 37;
pub const FT_EUI64: ftenum = 38;
pub const FT_AX25: ftenum = 39;
pub const FT_VINES: ftenum = 40;
pub const FT_REL_OID: ftenum = 41;
pub const FT_SYSTEM_ID: ftenum = 42;
pub const FT_STRINGZPAD: ftenum = 43;
pub const FT_FCWWN: ftenum = 44;
pub const FT_STRINGZTRUNC: ftenum = 45;
pub const FT_NUM_TYPES: ftenum = 46;
pub type ftenum = ::std::os::raw::c_uint;
pub type fvalue_t = u8;
#[doc = "< none"]
pub const BASE_NONE: field_display_e = 0;
#[doc = "< decimal [integer, float]"]
pub const BASE_DEC: field_display_e = 1;
#[doc = "< hexadecimal [integer, float]"]
pub const BASE_HEX: field_display_e = 2;
#[doc = "< octal [integer]"]
pub const BASE_OCT: field_display_e = 3;
#[doc = "< decimal (hexadecimal) [integer]"]
pub const BASE_DEC_HEX: field_display_e = 4;
#[doc = "< hexadecimal (decimal) [integer]"]
pub const BASE_HEX_DEC: field_display_e = 5;
#[doc = "< call custom routine to format [integer, float]"]
pub const BASE_CUSTOM: field_display_e = 6;
#[doc = "< exponential [float]"]
pub const BASE_EXP: field_display_e = 7;
#[doc = "< hexadecimal bytes with a period (.) between each byte"]
pub const SEP_DOT: field_display_e = 8;
#[doc = "< hexadecimal bytes with a dash (-) between each byte"]
pub const SEP_DASH: field_display_e = 9;
#[doc = "< hexadecimal bytes with a colon (:) between each byte"]
pub const SEP_COLON: field_display_e = 10;
#[doc = "< hexadecimal bytes with a space between each byte"]
pub const SEP_SPACE: field_display_e = 11;
#[doc = "< Used for IPv4 address that shouldn't be resolved (like for netmasks)"]
pub const BASE_NETMASK: field_display_e = 12;
#[doc = "< UDP port"]
pub const BASE_PT_UDP: field_display_e = 13;
#[doc = "< TCP port"]
pub const BASE_PT_TCP: field_display_e = 14;
#[doc = "< DCCP port"]
pub const BASE_PT_DCCP: field_display_e = 15;
#[doc = "< SCTP port"]
pub const BASE_PT_SCTP: field_display_e = 16;
#[doc = "< OUI resolution"]
pub const BASE_OUI: field_display_e = 17;
#[doc = "< local time in our time zone, with month and day"]
pub const ABSOLUTE_TIME_LOCAL: field_display_e = 18;
#[doc = "< UTC, with month and day"]
pub const ABSOLUTE_TIME_UTC: field_display_e = 19;
#[doc = "< UTC, with 1-origin day-of-year"]
pub const ABSOLUTE_TIME_DOY_UTC: field_display_e = 20;
#[doc = "< UTC, with \"NULL\" when timestamp is all zeros"]
pub const ABSOLUTE_TIME_NTP_UTC: field_display_e = 21;
#[doc = "< Unix time"]
pub const ABSOLUTE_TIME_UNIX: field_display_e = 22;
#[doc = "< Replace all whitespace characters (newline, formfeed, etc) with \"space\"."]
pub const BASE_STR_WSP: field_display_e = 23;
pub type field_display_e = ::std::os::raw::c_uint;
#[doc = "< Field is not referenced"]
pub const HF_REF_TYPE_NONE: hf_ref_type = 0;
#[doc = "< Field is indirectly referenced (only applicable for FT_PROTOCOL) via. its child"]
pub const HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
#[doc = "< Field is directly referenced"]
pub const HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = ::std::os::raw::c_uint;
#[doc = " information describing a header field"]
pub type header_field_info = _header_field_info;
#[doc = " information describing a header field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    #[doc = "< [FIELDNAME] full name of this field"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDFILTERNAME] filter name of this field"]
    pub abbrev: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDTYPE] field type, one of FT_ (from ftypes.h)"]
    pub type_: ftenum,
    #[doc = "< [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask"]
    pub display: ::std::os::raw::c_int,
    #[doc = "< [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,\ntypically converted by VALS(), RVALS() or TFS().\nIf this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the\nassociated protocol_t structure"]
    pub strings: *const ::std::os::raw::c_void,
    #[doc = "< [BITMASK] bitmask of interesting bits"]
    pub bitmask: guint64,
    #[doc = "< [FIELDDESCR] Brief description of field"]
    pub blurb: *const ::std::os::raw::c_char,
    #[doc = "< Field ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< parent protocol tree"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "< is this field referenced by a filter"]
    pub ref_type: hf_ref_type,
    #[doc = "< ID of previous hfinfo with same abbrev"]
    pub same_name_prev_id: ::std::os::raw::c_int,
    #[doc = "< Link to next hfinfo with same abbrev"]
    pub same_name_next: *mut header_field_info,
}
#[test]
fn bindgen_test_layout__header_field_info() {
    const UNINIT: ::std::mem::MaybeUninit<_header_field_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_header_field_info>(),
        72usize,
        concat!("Size of: ", stringify!(_header_field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_header_field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_header_field_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abbrev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(abbrev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(bitmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blurb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(blurb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_type) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(ref_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_name_prev_id) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_prev_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).same_name_next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_next)
        )
    );
}
#[doc = " Used when registering many fields at once, using proto_register_field_array()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hf_register_info {
    #[doc = "< written to by register() function"]
    pub p_id: *mut ::std::os::raw::c_int,
    #[doc = "< the field info to be registered"]
    pub hfinfo: header_field_info,
}
#[test]
fn bindgen_test_layout_hf_register_info() {
    const UNINIT: ::std::mem::MaybeUninit<hf_register_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hf_register_info>(),
        80usize,
        concat!("Size of: ", stringify!(hf_register_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hf_register_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hf_register_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(p_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(hfinfo)
        )
    );
}
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
#[repr(C)]
#[repr(align(1))]
pub struct _item_label_t {
    pub _bindgen_opaque_blob: [u8; 240usize],
}
#[test]
fn bindgen_test_layout__item_label_t() {
    assert_eq!(
        ::std::mem::size_of::<_item_label_t>(),
        240usize,
        concat!("Size of: ", stringify!(_item_label_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_item_label_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_item_label_t))
    );
}
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
pub type item_label_t = _item_label_t;
#[doc = " Contains the field information for the proto_item."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct field_info {
    #[doc = "< pointer to registered field information"]
    pub hfinfo: *mut header_field_info,
    #[doc = "< current start of data in field_info.ds_tvb"]
    pub start: gint,
    #[doc = "< current data length of item in field_info.ds_tvb"]
    pub length: gint,
    #[doc = "< start of appendix data"]
    pub appendix_start: gint,
    #[doc = "< length of appendix data"]
    pub appendix_length: gint,
    #[doc = "< one of ETT_ or -1"]
    pub tree_type: gint,
    #[doc = "< bitfield like FI_GENERATED, ..."]
    pub flags: guint32,
    #[doc = "< string for GUI tree"]
    pub rep: *mut item_label_t,
    #[doc = "< data source tvbuff"]
    pub ds_tvb: *mut tvbuff_t,
    pub value: *mut fvalue_t,
    #[doc = "< Hierarchical layer number, for all protocols in the tree."]
    pub total_layer_num: ::std::os::raw::c_int,
    #[doc = "< Protocol layer number, so 1st, 2nd, 3rd, ... for protocol X."]
    pub proto_layer_num: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_field_info() {
    const UNINIT: ::std::mem::MaybeUninit<field_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<field_info>(),
        64usize,
        concat!("Size of: ", stringify!(field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(field_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(hfinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendix_start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(appendix_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendix_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(appendix_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tree_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(tree_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(rep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ds_tvb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(ds_tvb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_layer_num) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(total_layer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_layer_num) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(field_info),
            "::",
            stringify!(proto_layer_num)
        )
    );
}
#[doc = " One of these exists for the entire protocol tree. Each proto_node\n in the protocol tree points to the same copy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tree_data_t {
    pub interesting_hfids: *mut GHashTable,
    pub visible: gboolean,
    pub fake_protocols: gboolean,
    pub count: guint,
    pub pinfo: *mut _packet_info,
}
#[test]
fn bindgen_test_layout_tree_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<tree_data_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tree_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(tree_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tree_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tree_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interesting_hfids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(interesting_hfids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fake_protocols) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(fake_protocols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pinfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_data_t),
            "::",
            stringify!(pinfo)
        )
    );
}
#[doc = " Each proto_tree, proto_item is one of these."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _proto_node {
    pub first_child: *mut _proto_node,
    pub last_child: *mut _proto_node,
    pub next: *mut _proto_node,
    pub parent: *mut _proto_node,
    pub finfo: *mut field_info,
    pub tree_data: *mut tree_data_t,
}
#[test]
fn bindgen_test_layout__proto_node() {
    const UNINIT: ::std::mem::MaybeUninit<_proto_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_proto_node>(),
        48usize,
        concat!("Size of: ", stringify!(_proto_node))
    );
    assert_eq!(
        ::std::mem::align_of::<_proto_node>(),
        8usize,
        concat!("Alignment of ", stringify!(_proto_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(first_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_child) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(last_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(finfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tree_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_proto_node),
            "::",
            stringify!(tree_data)
        )
    );
}
#[doc = " Each proto_tree, proto_item is one of these."]
pub type proto_node = _proto_node;
#[doc = " A protocol tree element."]
pub type proto_tree = proto_node;
#[doc = " A protocol item element."]
pub type proto_item = proto_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_plugin {
    pub register_protoinfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_handoff: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_proto_plugin() {
    const UNINIT: ::std::mem::MaybeUninit<proto_plugin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proto_plugin>(),
        16usize,
        concat!("Size of: ", stringify!(proto_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<proto_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(proto_plugin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_protoinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_protoinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_handoff) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(proto_plugin),
            "::",
            stringify!(register_handoff)
        )
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Register dissector plugin with the plugin system."]
    pub fn proto_register_plugin(plugin: *const proto_plugin);
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Create a subtree under an existing item.\n@param pi the parent item of the new subtree\n@param idx one of the ett_ array elements registered with proto_register_subtree_array()\n@return the new subtree"]
    pub fn proto_item_add_subtree(pi: *mut proto_item, idx: gint) -> *mut proto_tree;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Replace text of item after it already has been created.\n@param pi the item to set the text\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_set_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Append to text of item after it has already been created.\n@param pi the item to append the text to\n@param format printf like format string\n@param ... printf like parameters"]
    pub fn proto_item_append_text(pi: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn proto_tree_add_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a FT_NONE field to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_none_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@return the newly created item"]
    pub fn proto_tree_add_bytes(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree like proto_tree_add_bytes,\nbut used when the tvb data length does not match the bytes length.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param ptr_length length of data in start_ptr\n@return the newly created item"]
    pub fn proto_tree_add_bytes_with_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        ptr_length: gint,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param start_ptr pointer to the data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_bytes_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a FT_GUID to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@return the newly created item"]
    pub fn proto_tree_add_guid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value_ptr data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_guid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add an FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC to a\nproto_tree. The value passed in should be a UTF-8 encoded null terminated\nstring, such as produced by tvb_get_string_enc(), regardless of the original\npacket data.\n\nThis function is used to add a custom string *value* to the protocol tree.\nDo not format the string value for display, for example by using format_text().\nThe input string represents packet data, not a display label. Formatting\nlabels is a concern of the UI. Doing that here would change the meaning of the packet\ndata, restrict the options for formatting later and make display filtering unintuitive\nfor whitespace and other special characters.\n\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a formatted FT_STRING, FT_STRINGZ, FT_STRINGZPAD, or FT_STRINGZTRUNC\nto a proto_tree, with the format generating the entire string for the\nentry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_string_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a FT_BOOLEAN to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_boolean_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a FT_FLOAT to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating\nthe entire string for the entry, including any field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_float_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add one of FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,\nwith the format generating the entire string for the entry, including any\nfield name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_uint_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add one of FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@return the newly created item"]
    pub fn proto_tree_add_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,\nwith the format generating the entire string for the entry, including\nany field name.\n@param tree the tree to append this item to\n@param hfindex field index\n@param tvb the tv buffer of the current data\n@param start start of data in tvb\n@param length length of data in tvb\n@param value data to display\n@param format printf like format string\n@param ... printf like parameters\n@return the newly created item"]
    pub fn proto_tree_add_int_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Register a new protocol.\n@param name the full name of the new protocol\n@param short_name abbreviated name of the new protocol\n@param filter_name protocol name used for a display filter string\n@return the new protocol handle"]
    pub fn proto_register_protocol(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Register a header_field array.\n@param parent the protocol handle from proto_register_protocol()\n@param hf the hf_register_info array\n@param num_records the number of records in hf"]
    pub fn proto_register_field_array(
        parent: ::std::os::raw::c_int,
        hf: *mut hf_register_info,
        num_records: ::std::os::raw::c_int,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Register a protocol subtree (ett) array.\n@param indices array of ett indices\n@param num_indices the number of records in indices"]
    pub fn proto_register_subtree_array(
        indices: *const *mut gint,
        num_indices: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range_admin_tag {
    pub low: guint32,
    pub high: guint32,
}
#[test]
fn bindgen_test_layout_range_admin_tag() {
    const UNINIT: ::std::mem::MaybeUninit<range_admin_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<range_admin_tag>(),
        8usize,
        concat!("Size of: ", stringify!(range_admin_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<range_admin_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(range_admin_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range_admin_tag),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(range_admin_tag),
            "::",
            stringify!(high)
        )
    );
}
pub type range_admin_t = range_admin_tag;
#[doc = " user specified range(s)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_range {
    #[doc = "< number of entries in ranges"]
    pub nranges: guint,
    #[doc = "< variable-length array"]
    pub ranges: [range_admin_t; 1usize],
}
#[test]
fn bindgen_test_layout_epan_range() {
    const UNINIT: ::std::mem::MaybeUninit<epan_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<epan_range>(),
        12usize,
        concat!("Size of: ", stringify!(epan_range))
    );
    assert_eq!(
        ::std::mem::align_of::<epan_range>(),
        4usize,
        concat!("Alignment of ", stringify!(epan_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nranges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_range),
            "::",
            stringify!(nranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ranges) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(epan_range),
            "::",
            stringify!(ranges)
        )
    );
}
#[doc = "  Helper routines for column utility structures and routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn epan_get_version() -> *const gchar;
}
pub type column_info = epan_column_info;
#[doc = "< 0) Absolute date, as YYYY-MM-DD, and time"]
pub const COL_ABS_YMD_TIME: _bindgen_ty_21 = 0;
#[doc = "< 1) Absolute date, as YYYY/DOY, and time"]
pub const COL_ABS_YDOY_TIME: _bindgen_ty_21 = 1;
#[doc = "< 2) Absolute time"]
pub const COL_ABS_TIME: _bindgen_ty_21 = 2;
#[doc = "< 3) Cumulative number of bytes"]
pub const COL_CUMULATIVE_BYTES: _bindgen_ty_21 = 3;
#[doc = "< 4) Custom column (any filter name's contents)"]
pub const COL_CUSTOM: _bindgen_ty_21 = 4;
#[doc = "< 5) Delta time"]
pub const COL_DELTA_TIME: _bindgen_ty_21 = 5;
#[doc = "< 6) Delta time displayed"]
pub const COL_DELTA_TIME_DIS: _bindgen_ty_21 = 6;
#[doc = "< 7) Resolved dest"]
pub const COL_RES_DST: _bindgen_ty_21 = 7;
#[doc = "< 8) Unresolved dest"]
pub const COL_UNRES_DST: _bindgen_ty_21 = 8;
#[doc = "< 9) Resolved dest port"]
pub const COL_RES_DST_PORT: _bindgen_ty_21 = 9;
#[doc = "< 10) Unresolved dest port"]
pub const COL_UNRES_DST_PORT: _bindgen_ty_21 = 10;
#[doc = "< 11) Destination address"]
pub const COL_DEF_DST: _bindgen_ty_21 = 11;
#[doc = "< 12) Destination port"]
pub const COL_DEF_DST_PORT: _bindgen_ty_21 = 12;
#[doc = "< 13) Expert Info"]
pub const COL_EXPERT: _bindgen_ty_21 = 13;
#[doc = "< 14) FW-1 monitor interface/direction"]
pub const COL_IF_DIR: _bindgen_ty_21 = 14;
#[doc = "< 15) IEEE 802.11 (and WiMax?) - Channel"]
pub const COL_FREQ_CHAN: _bindgen_ty_21 = 15;
#[doc = "< 16) Data link layer dest address"]
pub const COL_DEF_DL_DST: _bindgen_ty_21 = 16;
#[doc = "< 17) Data link layer source address"]
pub const COL_DEF_DL_SRC: _bindgen_ty_21 = 17;
#[doc = "< 18) Resolved DL dest"]
pub const COL_RES_DL_DST: _bindgen_ty_21 = 18;
#[doc = "< 19) Unresolved DL dest"]
pub const COL_UNRES_DL_DST: _bindgen_ty_21 = 19;
#[doc = "< 20) Resolved DL source"]
pub const COL_RES_DL_SRC: _bindgen_ty_21 = 20;
#[doc = "< 21) Unresolved DL source"]
pub const COL_UNRES_DL_SRC: _bindgen_ty_21 = 21;
#[doc = "< 22) IEEE 802.11 - received signal strength"]
pub const COL_RSSI: _bindgen_ty_21 = 22;
#[doc = "< 23) IEEE 802.11 - TX rate in Mbps"]
pub const COL_TX_RATE: _bindgen_ty_21 = 23;
#[doc = "< 24) IP DSCP Value"]
pub const COL_DSCP_VALUE: _bindgen_ty_21 = 24;
#[doc = "< 25) Description"]
pub const COL_INFO: _bindgen_ty_21 = 25;
#[doc = "< 26) Resolved net dest"]
pub const COL_RES_NET_DST: _bindgen_ty_21 = 26;
#[doc = "< 27) Unresolved net dest"]
pub const COL_UNRES_NET_DST: _bindgen_ty_21 = 27;
#[doc = "< 28) Resolved net source"]
pub const COL_RES_NET_SRC: _bindgen_ty_21 = 28;
#[doc = "< 29) Unresolved net source"]
pub const COL_UNRES_NET_SRC: _bindgen_ty_21 = 29;
#[doc = "< 30) Network layer dest address"]
pub const COL_DEF_NET_DST: _bindgen_ty_21 = 30;
#[doc = "< 31) Network layer source address"]
pub const COL_DEF_NET_SRC: _bindgen_ty_21 = 31;
#[doc = "< 32) Packet list item number"]
pub const COL_NUMBER: _bindgen_ty_21 = 32;
#[doc = "< 33) Packet length in bytes"]
pub const COL_PACKET_LENGTH: _bindgen_ty_21 = 33;
#[doc = "< 34) Protocol"]
pub const COL_PROTOCOL: _bindgen_ty_21 = 34;
#[doc = "< 35) Relative time"]
pub const COL_REL_TIME: _bindgen_ty_21 = 35;
#[doc = "< 36) Source address"]
pub const COL_DEF_SRC: _bindgen_ty_21 = 36;
#[doc = "< 37) Source port"]
pub const COL_DEF_SRC_PORT: _bindgen_ty_21 = 37;
#[doc = "< 38) Resolved source"]
pub const COL_RES_SRC: _bindgen_ty_21 = 38;
#[doc = "< 39) Unresolved source"]
pub const COL_UNRES_SRC: _bindgen_ty_21 = 39;
#[doc = "< 40) Resolved source port"]
pub const COL_RES_SRC_PORT: _bindgen_ty_21 = 40;
#[doc = "< 41) Unresolved source port"]
pub const COL_UNRES_SRC_PORT: _bindgen_ty_21 = 41;
#[doc = "< 42) UTC date, as YYYY-MM-DD, and time"]
pub const COL_UTC_YMD_TIME: _bindgen_ty_21 = 42;
#[doc = "< 43) UTC date, as YYYY/DOY, and time"]
pub const COL_UTC_YDOY_TIME: _bindgen_ty_21 = 43;
#[doc = "< 44) UTC time"]
pub const COL_UTC_TIME: _bindgen_ty_21 = 44;
#[doc = "< 45) Command line-specified time (default relative)"]
pub const COL_CLS_TIME: _bindgen_ty_21 = 45;
#[doc = "< 46) Should always be last"]
pub const NUM_COL_FMTS: _bindgen_ty_21 = 46;
#[doc = " All of the possible columns in summary listing.\n\n NOTE1: The entries MUST remain in this order, or else you need to reorder\n        the slist[] and dlist[] arrays in column.c to match!\n\n NOTE2: Please add the COL_XYZ entry in the appropriate spot, such that the\n        dlist[] array remains in alphabetical order!"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Clears the text of a column element.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear(cinfo: *mut column_info, col: gint);
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Set (replace) the text of a column element, the text won't be formatted or copied.\n\n Use this for simple static strings like protocol names. Don't use for untrusted strings\n or strings that may contain unprintable characters.\n\n Usually used to set const strings!\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param str the string to set"]
    pub fn col_set_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add (replace) the text of a column element, the text will be formatted and copied.\n\n Unprintable characters according to isprint() are escaped.\n\n @param cinfo the current packet row\n @param col the column to use, e.g. COL_INFO\n @param str the string to add"]
    pub fn col_add_str(cinfo: *mut column_info, col: gint, str_: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
pub type dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Type of a heuristic dissector, used in heur_dissector_add().\n\n @param tvb the tvbuff with the (remaining) packet data\n @param pinfo the packet info of this packet (additional info)\n @param tree the protocol tree to be build or NULL\n @return TRUE if the packet was recognized by the sub-dissector (stop dissection here)"]
pub type heur_dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        arg1: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
pub const HEURISTIC_DISABLE: heuristic_enable_e = 0;
pub const HEURISTIC_ENABLE: heuristic_enable_e = 1;
pub type heuristic_enable_e = ::std::os::raw::c_uint;
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_uint_with_preference(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_uint_range(
        abbrev: *const ::std::os::raw::c_char,
        range: *mut epan_range,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_uint_range_with_preference(
        abbrev: *const ::std::os::raw::c_char,
        range_str: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_custom_table_handle(
        name: *const ::std::os::raw::c_char,
        pattern: *mut ::std::os::raw::c_void,
        handle: dissector_handle_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _guid_key {
    pub guid: e_guid_t,
    pub ver: guint16,
}
#[test]
fn bindgen_test_layout__guid_key() {
    const UNINIT: ::std::mem::MaybeUninit<_guid_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_guid_key>(),
        20usize,
        concat!("Size of: ", stringify!(_guid_key))
    );
    assert_eq!(
        ::std::mem::align_of::<_guid_key>(),
        4usize,
        concat!("Alignment of ", stringify!(_guid_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_guid_key),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_guid_key),
            "::",
            stringify!(ver)
        )
    );
}
pub type guid_key = _guid_key;
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_guid(
        name: *const ::std::os::raw::c_char,
        guid_val: *mut guid_key,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_for_decode_as(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn dissector_add_for_decode_as_with_preference(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Add a sub-dissector to a heuristic dissector list.\n  Call this in the proto_handoff function of the sub-dissector.\n\n @param name the name of the heuristic dissector table into which to register the dissector, e.g. \"tcp\"\n @param dissector the sub-dissector to be registered\n @param display_name the string used to present heuristic to user, e.g. \"HTTP over TCP\"\n @param internal_name the string used for \"internal\" use to identify heuristic, e.g. \"http_tcp\"\n @param proto the protocol id of the sub-dissector\n @param enable initially enabled or not"]
    pub fn heur_dissector_add(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        display_name: *const ::std::os::raw::c_char,
        internal_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        enable: heuristic_enable_e,
    );
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " Create an anonymous handle for a dissector."]
    pub fn create_dissector_handle(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn add_new_data_source(
        pinfo: *mut packet_info,
        tvb: *mut tvbuff_t,
        name: *const ::std::os::raw::c_char,
    );
}
pub const CONVERSATION_NONE: conversation_type = 0;
pub const CONVERSATION_SCTP: conversation_type = 1;
pub const CONVERSATION_TCP: conversation_type = 2;
pub const CONVERSATION_UDP: conversation_type = 3;
pub const CONVERSATION_DCCP: conversation_type = 4;
pub const CONVERSATION_IPX: conversation_type = 5;
pub const CONVERSATION_NCP: conversation_type = 6;
pub const CONVERSATION_EXCHG: conversation_type = 7;
pub const CONVERSATION_DDP: conversation_type = 8;
pub const CONVERSATION_SBCCS: conversation_type = 9;
pub const CONVERSATION_IDP: conversation_type = 10;
pub const CONVERSATION_TIPC: conversation_type = 11;
pub const CONVERSATION_USB: conversation_type = 12;
pub const CONVERSATION_I2C: conversation_type = 13;
pub const CONVERSATION_IBQP: conversation_type = 14;
pub const CONVERSATION_BLUETOOTH: conversation_type = 15;
pub const CONVERSATION_TDMOP: conversation_type = 16;
pub const CONVERSATION_DVBCI: conversation_type = 17;
pub const CONVERSATION_ISO14443: conversation_type = 18;
pub const CONVERSATION_ISDN: conversation_type = 19;
pub const CONVERSATION_H223: conversation_type = 20;
pub const CONVERSATION_X25: conversation_type = 21;
pub const CONVERSATION_IAX2: conversation_type = 22;
pub const CONVERSATION_DLCI: conversation_type = 23;
pub const CONVERSATION_ISUP: conversation_type = 24;
pub const CONVERSATION_BICC: conversation_type = 25;
pub const CONVERSATION_GSMTAP: conversation_type = 26;
pub const CONVERSATION_IUUP: conversation_type = 27;
pub const CONVERSATION_DVBBBF: conversation_type = 28;
pub const CONVERSATION_IWARP_MPA: conversation_type = 29;
pub const CONVERSATION_BT_UTP: conversation_type = 30;
pub const CONVERSATION_LOG: conversation_type = 31;
pub const CONVERSATION_LTP: conversation_type = 32;
pub const CONVERSATION_MCTP: conversation_type = 33;
pub const CONVERSATION_NVME_MI: conversation_type = 34;
pub const CONVERSATION_BP: conversation_type = 35;
pub const CONVERSATION_SNMP: conversation_type = 36;
pub const CONVERSATION_QUIC: conversation_type = 37;
pub const CONVERSATION_IDN: conversation_type = 38;
pub type conversation_type = ::std::os::raw::c_uint;
pub const CE_CONVERSATION_TYPE: conversation_element_type = 0;
pub const CE_ADDRESS: conversation_element_type = 1;
pub const CE_PORT: conversation_element_type = 2;
pub const CE_STRING: conversation_element_type = 3;
pub const CE_UINT: conversation_element_type = 4;
pub const CE_UINT64: conversation_element_type = 5;
pub const CE_INT: conversation_element_type = 6;
#[doc = " Conversation element type."]
pub type conversation_element_type = ::std::os::raw::c_uint;
#[doc = " Elements used to identify conversations for *_full routines and\n pinfo->conv_elements.\n Arrays must be terminated with an element .type set to CE_CONVERSATION_TYPE.\n\n This is currently set only by conversation_set_elements_by_id(); it\n is not set for conversations identified by address/port endpoints.\n\n In find_conversation_pinfo() and find_or_create_conversation(), if\n any dissector has set this, then, unless some dissector has set the\n pair of address/port endpoints (see below), the array of elements\n is used to look up or create the conversation.  Otherwise, the\n current addresses and ports in the packet_info structure are used.\n\n XXX - is there any reason why we shouldn't use an array of conversation\n elements, with the appropriate addresses and ports, and set it for\n all protocols that use conversations specified by a pair of address/port\n endpoints?  That might simplify find_conversation_pinfo() by having\n them always use the array of elements if it's present, and just fail if\n it's not."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct conversation_element {
    pub type_: conversation_element_type,
    pub __bindgen_anon_1: conversation_element__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union conversation_element__bindgen_ty_1 {
    pub conversation_type_val: conversation_type,
    pub addr_val: address,
    pub port_val: ::std::os::raw::c_uint,
    pub str_val: *const ::std::os::raw::c_char,
    pub uint_val: ::std::os::raw::c_uint,
    pub uint64_val: u64,
    pub int_val: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_conversation_element__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<conversation_element__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conversation_element__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(conversation_element__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation_element__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(conversation_element__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conversation_type_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(conversation_type_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(addr_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(port_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(str_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(uint_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint64_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(uint64_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element__bindgen_ty_1),
            "::",
            stringify!(int_val)
        )
    );
}
#[test]
fn bindgen_test_layout_conversation_element() {
    const UNINIT: ::std::mem::MaybeUninit<conversation_element> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conversation_element>(),
        32usize,
        concat!("Size of: ", stringify!(conversation_element))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation_element>(),
        8usize,
        concat!("Alignment of ", stringify!(conversation_element))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation_element),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " Elements used to identify conversations for *_full routines and\n pinfo->conv_elements.\n Arrays must be terminated with an element .type set to CE_CONVERSATION_TYPE.\n\n This is currently set only by conversation_set_elements_by_id(); it\n is not set for conversations identified by address/port endpoints.\n\n In find_conversation_pinfo() and find_or_create_conversation(), if\n any dissector has set this, then, unless some dissector has set the\n pair of address/port endpoints (see below), the array of elements\n is used to look up or create the conversation.  Otherwise, the\n current addresses and ports in the packet_info structure are used.\n\n XXX - is there any reason why we shouldn't use an array of conversation\n elements, with the appropriate addresses and ports, and set it for\n all protocols that use conversations specified by a pair of address/port\n endpoints?  That might simplify find_conversation_pinfo() by having\n them always use the array of elements if it's present, and just fail if\n it's not."]
pub type conversation_element_t = conversation_element;
#[doc = " Data structure representing a conversation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation {
    pub next: *mut conversation,
    #[doc = " pointer to next conversation on hash chain"]
    pub last: *mut conversation,
    #[doc = " pointer to the last conversation on hash chain"]
    pub latest_found: *mut conversation,
    #[doc = " pointer to the last conversation on hash chain"]
    pub conv_index: guint32,
    #[doc = " unique ID for conversation"]
    pub setup_frame: guint32,
    #[doc = " frame number that setup this conversation"]
    pub last_frame: guint32,
    #[doc = " highest frame number in this conversation"]
    pub data_list: *mut wmem_tree_t,
    #[doc = " list of data associated with conversation"]
    pub dissector_tree: *mut wmem_tree_t,
    #[doc = " tree containing protocol dissector client associated with conversation"]
    pub options: guint,
    #[doc = " wildcard flags"]
    pub key_ptr: *mut conversation_element_t,
}
#[test]
fn bindgen_test_layout_conversation() {
    const UNINIT: ::std::mem::MaybeUninit<conversation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conversation>(),
        72usize,
        concat!("Size of: ", stringify!(conversation))
    );
    assert_eq!(
        ::std::mem::align_of::<conversation>(),
        8usize,
        concat!("Alignment of ", stringify!(conversation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latest_found) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(latest_found)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conv_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(conv_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setup_frame) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(setup_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_frame) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(last_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_list) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(data_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dissector_tree) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(dissector_tree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_ptr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(conversation),
            "::",
            stringify!(key_ptr)
        )
    );
}
#[doc = " Data structure representing a conversation."]
pub type conversation_t = conversation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conversation_addr_port_endpoints {
    _unused: [u8; 0],
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    #[doc = " A helper function that calls find_conversation() and, if a conversation is\n not found, calls conversation_new().\n The frame number and addresses are taken from pinfo.\n No options are used, though we could extend this API to include an options\n parameter.\n\n @param pinfo Packet info.\n @return The existing or new conversation."]
    pub fn find_or_create_conversation(pinfo: *mut packet_info) -> *mut conversation_t;
}
#[cfg_attr(windows, link(name = "libwireshark", kind = "raw-dylib"))]
extern "C" {
    pub fn conversation_set_dissector(
        conversation: *mut conversation_t,
        handle: dissector_handle_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_pseudo_header {
    pub _address: u8,
}
